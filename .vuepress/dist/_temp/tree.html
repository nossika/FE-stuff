<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>杂 | 前端工程师的自我修养</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="一本关于前端开发领域知识的书">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.541eff33.js" as="script"><link rel="preload" href="/assets/js/2.df51b1a1.js" as="script"><link rel="preload" href="/assets/js/19.314c4b0a.js" as="script"><link rel="prefetch" href="/assets/js/10.f45531ad.js"><link rel="prefetch" href="/assets/js/11.f2fa7fb0.js"><link rel="prefetch" href="/assets/js/12.fd00ff89.js"><link rel="prefetch" href="/assets/js/13.ab76117e.js"><link rel="prefetch" href="/assets/js/14.e99d291c.js"><link rel="prefetch" href="/assets/js/15.7b117e72.js"><link rel="prefetch" href="/assets/js/16.a9eb127b.js"><link rel="prefetch" href="/assets/js/17.29c4950a.js"><link rel="prefetch" href="/assets/js/18.a2b13614.js"><link rel="prefetch" href="/assets/js/20.11e28cb4.js"><link rel="prefetch" href="/assets/js/21.9803bd7c.js"><link rel="prefetch" href="/assets/js/22.829fdb3a.js"><link rel="prefetch" href="/assets/js/23.f021fe4e.js"><link rel="prefetch" href="/assets/js/24.5e91d629.js"><link rel="prefetch" href="/assets/js/25.4db55cb2.js"><link rel="prefetch" href="/assets/js/26.53a46dd9.js"><link rel="prefetch" href="/assets/js/27.e43943ce.js"><link rel="prefetch" href="/assets/js/28.8dab618d.js"><link rel="prefetch" href="/assets/js/29.ac1a1dbe.js"><link rel="prefetch" href="/assets/js/3.afde263c.js"><link rel="prefetch" href="/assets/js/30.4f891a36.js"><link rel="prefetch" href="/assets/js/31.05d46183.js"><link rel="prefetch" href="/assets/js/32.72855b3e.js"><link rel="prefetch" href="/assets/js/33.9f87a4dc.js"><link rel="prefetch" href="/assets/js/34.7d65bf32.js"><link rel="prefetch" href="/assets/js/35.81ced807.js"><link rel="prefetch" href="/assets/js/36.4b4918cf.js"><link rel="prefetch" href="/assets/js/37.0567a931.js"><link rel="prefetch" href="/assets/js/38.767168e3.js"><link rel="prefetch" href="/assets/js/39.0be6b4f7.js"><link rel="prefetch" href="/assets/js/4.f5528398.js"><link rel="prefetch" href="/assets/js/40.4e720429.js"><link rel="prefetch" href="/assets/js/41.4632404e.js"><link rel="prefetch" href="/assets/js/42.daf55a44.js"><link rel="prefetch" href="/assets/js/43.4e2d6381.js"><link rel="prefetch" href="/assets/js/44.dd3ee646.js"><link rel="prefetch" href="/assets/js/45.32a43758.js"><link rel="prefetch" href="/assets/js/46.39a14a29.js"><link rel="prefetch" href="/assets/js/47.a8da94dd.js"><link rel="prefetch" href="/assets/js/48.175a0ee3.js"><link rel="prefetch" href="/assets/js/49.ab7acb19.js"><link rel="prefetch" href="/assets/js/5.e6632aaa.js"><link rel="prefetch" href="/assets/js/50.d737dd9f.js"><link rel="prefetch" href="/assets/js/51.357659e1.js"><link rel="prefetch" href="/assets/js/52.b72c78dc.js"><link rel="prefetch" href="/assets/js/53.e9af4cbf.js"><link rel="prefetch" href="/assets/js/54.af3eb1a1.js"><link rel="prefetch" href="/assets/js/55.efe33535.js"><link rel="prefetch" href="/assets/js/56.28c9d8e3.js"><link rel="prefetch" href="/assets/js/57.c3dc65c0.js"><link rel="prefetch" href="/assets/js/58.fa3c2bc5.js"><link rel="prefetch" href="/assets/js/59.b4b08c79.js"><link rel="prefetch" href="/assets/js/6.7cef0524.js"><link rel="prefetch" href="/assets/js/60.6d713dc2.js"><link rel="prefetch" href="/assets/js/61.68312bd1.js"><link rel="prefetch" href="/assets/js/62.24126722.js"><link rel="prefetch" href="/assets/js/63.9547d783.js"><link rel="prefetch" href="/assets/js/64.97484b5b.js"><link rel="prefetch" href="/assets/js/65.75fe59b6.js"><link rel="prefetch" href="/assets/js/66.3405d813.js"><link rel="prefetch" href="/assets/js/67.cd0f9883.js"><link rel="prefetch" href="/assets/js/68.cc781c75.js"><link rel="prefetch" href="/assets/js/69.2e7df999.js"><link rel="prefetch" href="/assets/js/7.b3e9ee84.js"><link rel="prefetch" href="/assets/js/8.48bde48e.js"><link rel="prefetch" href="/assets/js/9.fc58e4c4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端工程师的自我修养</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/nossika/FE-guide" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/nossika/FE-guide" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ecma.html" class="sidebar-link">JS(ECMA)</a></li><li><a href="/js/dom.html" class="sidebar-link">JS(DOM/BOM)</a></li><li><a href="/js/engine.html" class="sidebar-link">V8引擎</a></li><li><a href="/js/thread.html" class="sidebar-link">单线程的JS</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML/CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/htmlcss/html.html" class="sidebar-link">HTML</a></li><li><a href="/htmlcss/css.html" class="sidebar-link">CSS</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>WEB</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web/protocol.html" class="sidebar-link">协议</a></li><li><a href="/web/cache.html" class="sidebar-link">缓存</a></li><li><a href="/web/security.html" class="sidebar-link">安全</a></li><li><a href="/web/cdn.html" class="sidebar-link">CDN</a></li><li><a href="/web/auth.html" class="sidebar-link">权限 &amp; 认证</a></li><li><a href="/web/communication.html" class="sidebar-link">通信</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>性能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/performance/render.html" class="sidebar-link">浏览器渲染</a></li><li><a href="/performance/analysis.html" class="sidebar-link">性能分析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/communication.html" class="sidebar-link">组件通信</a></li><li><a href="/react/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/react/api.html" class="sidebar-link">API</a></li><li><a href="/react/principle.html" class="sidebar-link">原理相关</a></li><li><a href="/react/lib.html" class="sidebar-link">第三方库</a></li><li><a href="/react/hooks.html" class="sidebar-link">Hooks VS Class</a></li><li><a href="/react/diff.html" class="sidebar-link">Vue vs React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/communication.html" class="sidebar-link">组件通信</a></li><li><a href="/vue/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/vue/api.html" class="sidebar-link">API</a></li><li><a href="/vue/principle.html" class="sidebar-link">原理相关</a></li><li><a href="/vue/lib.html" class="sidebar-link">官方库</a></li><li><a href="/vue/ssr.html" class="sidebar-link">SSR</a></li><li><a href="/vue/hooks.html" class="sidebar-link">Hooks VS Option</a></li><li><a href="/vue/diff.html" class="sidebar-link">Vue vs React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/structure.html" class="sidebar-link">数据结构</a></li><li><a href="/algorithm/concept.html" class="sidebar-link">概念</a></li><li><a href="/algorithm/application.html" class="sidebar-link">算法题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机科学</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs/concept.html" class="sidebar-link">概念</a></li><li><a href="/cs/lang.html" class="sidebar-link">编程语言</a></li><li><a href="/cs/paradigm.html" class="sidebar-link">编程范式</a></li><li><a href="/cs/design.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/engineer/module.html" class="sidebar-link">模块化</a></li><li><a href="/engineer/build.html" class="sidebar-link">构建</a></li><li><a href="/engineer/coop.html" class="sidebar-link">协作</a></li><li><a href="/engineer/test.html" class="sidebar-link">测试</a></li><li><a href="/engineer/deploy.html" class="sidebar-link">部署</a></li><li><a href="/engineer/monitor.html" class="sidebar-link">监控</a></li><li><a href="/engineer/devops.html" class="sidebar-link">DevOps</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>NodeJS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/node/loop.html" class="sidebar-link">事件循环</a></li><li><a href="/node/dep.html" class="sidebar-link">依赖管理</a></li><li><a href="/node/api.html" class="sidebar-link">API</a></li><li><a href="/node/npm.html" class="sidebar-link">NPM</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>GoLang</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/go/main.html" class="sidebar-link">一些用法</a></li><li><a href="/go/diff-js.html" class="sidebar-link">和JS对比</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>others</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="杂"><a href="#杂" class="header-anchor">#</a> 杂</h1> <p>[TOC]</p> <h2 id="js-ecma"><a href="#js-ecma" class="header-anchor">#</a> JS（ECMA）</h2> <h3 id="数字转字符串-字符串转数字"><a href="#数字转字符串-字符串转数字" class="header-anchor">#</a> 数字转字符串 &amp; 字符串转数字</h3> <p>number + &quot;&quot; / number.toString() / String(number)</p> <p>+string / parseFloat(string) / Number(string)</p> <p>隐式转换规则，调用to根据preferType调用toString() / valueOf()</p> <p>Number() &amp; new Number() 区别: 为什么可以在基本属性上执行方法（比如(123).toString()）</p> <h3 id="隐式转换"><a href="#隐式转换" class="header-anchor">#</a> 隐式转换</h3> <p>toPrimitive(hint) hint：string/number/default</p> <p>string mode: toString =&gt; valueOf =&gt; error</p> <p>number mode: valueOf =&gt; toString =&gt; error</p> <h3 id="数组原型上的方法array-prototype"><a href="#数组原型上的方法array-prototype" class="header-anchor">#</a> 数组原型上的方法Array.prototype</h3> <p>影响原数组 / 返回新数组 / 遍历</p> <p>find、findIndex(ES6)</p> <p>includes(ES7)</p> <h3 id="es8"><a href="#es8" class="header-anchor">#</a> ES8</h3> <p>...Object</p> <p>await let of</p> <h3 id="object"><a href="#object" class="header-anchor">#</a> Object</h3> <h4 id="禁止修改属性"><a href="#禁止修改属性" class="header-anchor">#</a> 禁止修改属性</h4> <p>Object.freeze</p> <p>defineProperty writable</p> <p>defineProperty set</p> <h3 id="原型继承"><a href="#原型继承" class="header-anchor">#</a> 原型继承</h3> <h4 id="instance-a-、prototype-protoa-、constructor-a-之间关系"><a href="#instance-a-、prototype-protoa-、constructor-a-之间关系" class="header-anchor">#</a> instance(a)、prototype(protoA)、constructor(A)之间关系:</h4> <p>a ===&gt; protoA:  Object.getPrototypeOf(a);</p> <p>a ===&gt; A:  a.constructor;</p> <p>protoA ===&gt; A:  protoA.constructor;</p> <p>A ===&gt; protoA:  A.prototype;</p> <p>A ===&gt; a: new A();</p> <h4 id="class-extends-写法"><a href="#class-extends-写法" class="header-anchor">#</a> class extends 写法</h4> <h3 id="promise错误处理"><a href="#promise错误处理" class="header-anchor">#</a> Promise错误处理</h3> <p>能否 try { new Promise(..); } catch() {} ？ 为何</p> <p>对比</p> <p>new Promise(...).then(data =&gt; {}, error =&gt; {})</p> <p>new Promise(...).then(date =&gt; {}).catch(error =&gt; {})</p> <h3 id="settimeout-setinterval-处理循环"><a href="#settimeout-setinterval-处理循环" class="header-anchor">#</a> setTimeout &amp; setInterval 处理循环</h3> <p>setInterval可能连续多次触发（定时推送，不管内部函数是否执行完毕，因为JS引擎和定时器是两个不同线程各自执行）</p> <h3 id="esm、cjs"><a href="#esm、cjs" class="header-anchor">#</a> esm、cjs</h3> <p>import：编译时导入（静态），值引用，只读；</p> <p>require：运行时导入（动态），值拷贝</p> <p>循环引用区别</p> <p>import()动态，返回promise。</p> <h3 id="amd、cmd"><a href="#amd、cmd" class="header-anchor">#</a> AMD、CMD</h3> <p>AMD：依赖前置，requireJS</p> <p>CMD：依赖就近，seaJS</p> <p>浏览器中用法：type=&quot;module&quot;</p> <h3 id="数字精度"><a href="#数字精度" class="header-anchor">#</a> 数字精度</h3> <p>JS中能转换成整数的值都会用整数来存储，小数在底层用 IEEE-754 双精度（64位）浮点数来存储。</p> <p>64位：1符号位+11指数位+52有效数字位</p> <p>小数x转化成二进制是用 x = 1/2*a + 1/4*b + 1/8*c + 1/16*d ... 中的abcd等因子来表示。</p> <p>比如0.1 = 1/2*0 + 1/4*0 + 1/8*0 + 1/16*1 + 1/32*1 + 1/64*0  ... ，则0.1的二进制表示为00011001100...，去掉头部的0从1开始（头部的0可以在指数位表示），则有效数字部分为11001100...</p> <p>因此大部分小数无法精确存储，除了0.5/0.125/0.375这类数字</p> <h3 id="手写函数"><a href="#手写函数" class="header-anchor">#</a> 手写函数</h3> <p>实现Array.prototype.reduce/String.prototype.indexOf/Function.prototype.bind</p> <h3 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h3> <table><thead><tr><th style="text-align:left;">方法</th> <th style="text-align:center;">平均</th> <th style="text-align:center;">最快</th> <th style="text-align:center;">最慢</th> <th style="text-align:center;">空间</th></tr></thead> <tbody><tr><td style="text-align:left;">快排</td> <td style="text-align:center;">NlogN</td> <td style="text-align:center;">N2</td> <td style="text-align:center;">NlogN</td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:left;">冒泡</td> <td style="text-align:center;">N2</td> <td style="text-align:center;">N2</td> <td style="text-align:center;">N</td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:left;">插入</td> <td style="text-align:center;">N2</td> <td style="text-align:center;">N2</td> <td style="text-align:center;">N</td> <td style="text-align:center;">1</td></tr></tbody></table> <h3 id="尾调用优化"><a href="#尾调用优化" class="header-anchor">#</a> 尾调用优化</h3> <p>最后return一个函数，不依赖其他变量</p> <p>递归会产生多层函数调用栈，优化后只有一层</p> <h2 id="js-dom"><a href="#js-dom" class="header-anchor">#</a> JS（DOM）</h2> <h3 id="addeventlistener参数"><a href="#addeventlistener参数" class="header-anchor">#</a> addEventListener参数</h3> <p>冒泡、捕获，</p> <p>阻止冒泡</p> <h3 id="attribute操作-class操作"><a href="#attribute操作-class操作" class="header-anchor">#</a> attribute操作，class操作</h3> <h3 id="检测页面是否滚动到底部"><a href="#检测页面是否滚动到底部" class="header-anchor">#</a> 检测页面是否滚动到底部</h3> <h3 id="nodelist-htmlcollection"><a href="#nodelist-htmlcollection" class="header-anchor">#</a> NodeList &amp; HTMLCollection</h3> <p>Node.childNodes &amp; Node.children</p> <p>HTMLCollection不同：只包含elementNode（无textNode）、动态更新、namedItem方法</p> <h3 id="cssstyledeclaration"><a href="#cssstyledeclaration" class="header-anchor">#</a> CSSStyleDeclaration</h3> <p>CSSStyleDeclaration.setProperty('--color', 'red')</p> <h3 id="repaint-reflow"><a href="#repaint-reflow" class="header-anchor">#</a> repaint &amp; reflow</h3> <p>repaint: transform/visibility/background</p> <h2 id="js-bom"><a href="#js-bom" class="header-anchor">#</a> JS（BOM）</h2> <h3 id="区分pc-ios-android"><a href="#区分pc-ios-android" class="header-anchor">#</a> 区分pc/ios/android</h3> <h2 id="js-引擎"><a href="#js-引擎" class="header-anchor">#</a> JS 引擎</h2> <h3 id="v8"><a href="#v8" class="header-anchor">#</a> V8</h3> <p>runtime优化</p> <p>垃圾回收：</p> <p>新生代（from/to，存活晋升）、老生代（标记清除、标记整理）、大对象、jit</p> <h3 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h3> <p>GUI渲染线程、JS主线程、定时器线程、http请求线程</p> <p>setTimeout和Promise.then先后（macro、micro）</p> <h3 id="webworker"><a href="#webworker" class="header-anchor">#</a> WebWorker</h3> <p>Worker、SharedWorker（后者是独立进程，多tab页可共享一个）</p> <h2 id="mobile"><a href="#mobile" class="header-anchor">#</a> mobile</h2> <h3 id="flexible方案"><a href="#flexible方案" class="header-anchor">#</a> flexible方案</h3> <p>通过dpr来设置根节点的font-size + viewport的scale，页面使用设计图尺寸转换得到的rem，完成一个设计图到多种屏幕的适配</p> <h2 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h2> <h3 id="渲染"><a href="#渲染" class="header-anchor">#</a> 渲染</h3> <h4 id="过程"><a href="#过程" class="header-anchor">#</a> 过程</h4> <ul><li>style（确定每个节点应用的css规则）</li> <li>layout（reflow，重新计算各个节点位置）</li> <li>update layer tree（确定层叠顺序））（render layer）</li> <li>paint（计算节点绘制信息）</li> <li>composite（合成层）（graphics layer）</li></ul> <h4 id="gpu加速"><a href="#gpu加速" class="header-anchor">#</a> gpu加速</h4> <p>dom的绘制信息会被分成多个格栅上传gpu绘制</p> <p>某些情况下节点会被单独升级为合成层（比如：transform、opacity、canvas标签、手动加上will-change、有个比自己index低的合成层时 等），浏览器会独立绘制各个合成层，最后再复合而成最终页面，合成层内的dom变动只需要重绘这个层，更高效。</p> <p>结论：尽量用transform，合理利用will-change，把合成层的index尽可能高（避免自动创建不必要的合成层）</p> <h4 id="dom-update-、-dom-render"><a href="#dom-update-、-dom-render" class="header-anchor">#</a> dom update 、 dom render</h4> <ul><li>dom update的修改和获取是实时的，dom render是非实时（一般在一轮循环中，task和microtask都执行完后render，不一定每轮，因为事件循环频率可能比浏览器帧率高）</li> <li>所以vue使用promise.then来做dom更新，如果放在task里则下轮循环才更新</li></ul> <h3 id="输入url-页面展示"><a href="#输入url-页面展示" class="header-anchor">#</a> 输入url =&gt; 页面展示</h3> <ul><li><p>缓存查询</p></li> <li><p>dns</p></li> <li><p>打开tcp（tcp/ip协议）
后台负载均衡</p></li> <li><p>browser主进程发起请求 =&gt; 结果转交给render进程（tab页进程）处理
浏览器多进程（主进程，tab页，GPU等），tab页多线程（js引擎、GUI渲染、http请求、定时器、事件调度等）</p></li> <li><p>渲染（DOM树，CSS树，render树）
js解析会中断渲染（GUI渲染线程与js线程互斥）</p></li></ul> <h2 id="web"><a href="#web" class="header-anchor">#</a> WEB</h2> <h3 id="http协议"><a href="#http协议" class="header-anchor">#</a> http协议</h3> <p>基于tcp协议，req格式： <code>HTTP/1.1 /index.html GET\r\nConnection: keep-alive</code>，res格式：<code>HTTP/1.1 200 OK\r\nContent-type: text/plain\r\n\r\nsome text here</code></p> <p>1.1默认keep-alive，基于一次tcp（3次握手4次挥手）来发多次http请求</p> <p>状态码12345</p> <p>header(content-type/accept-encoding/user-agent/cookie/access-control-allow-origin/cache-control/e-tag/connection)</p> <p>缓存控制</p> <p>cookie</p> <p>http2：二进制、多路复用、主动推送、头部压缩</p> <p>https</p> <h3 id="前端缓存"><a href="#前端缓存" class="header-anchor">#</a> 前端缓存</h3> <h4 id="缓存位置-service-worker、memory-关闭tab清空-、disk"><a href="#缓存位置-service-worker、memory-关闭tab清空-、disk" class="header-anchor">#</a> 缓存位置：service worker、memory（关闭tab清空）、disk</h4> <h4 id="缓存顺序"><a href="#缓存顺序" class="header-anchor">#</a> 缓存顺序</h4> <p>：
SW内的fetch方法也遵守此规则</p> <p>强制缓存：cache-control(max-age)、expires</p> <p>协商缓存：e-tag、last-modified</p> <h4 id="no-store"><a href="#no-store" class="header-anchor">#</a> no-store</h4> <p>除了no-store的情况，当前页多次同一资源的请求（无论同步异步）只会从网络获取一次，其余都从memory获取（且不显示在network），如果no-store，则多少请求就获取多少次</p> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> websocket</h3> <p>和http一样基于tcp，http协议的升级</p> <p>tcp连接（连接实例称为socket）建立后，客户端发送http格式的报文<code>{ Connection: Upgrade, Upgrade: websocket, ... }</code>，服务端如果支持，也返回类似的确认报文，双方都对这个socket做好全双工通信的准备，即websocket连接建立。</p> <h3 id="socket"><a href="#socket" class="header-anchor">#</a> socket</h3> <p>套接字，可以理解为一个连接的实例，
比如说服务端客户端建立起一个tcp连接，那么两端各会有一个socket实例，可以对其调用各种方法来收发信息。</p> <h3 id="七层模型"><a href="#七层模型" class="header-anchor">#</a> 七层模型</h3> <p>应用：http</p> <p>会话：ssl/tls</p> <p>传输：tcp/udp</p> <p>网络：ip</p> <h3 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h3> <p>http header(cors)</p> <p>iframe</p> <p>jsonp</p> <p>nginx转发</p> <h3 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h3> <p>定位：chrome的network、performance、memory</p> <p>解决：</p> <p>dns：cdn</p> <p>缓存：response header、打包配置</p> <p>文件粒度：打包配置</p> <p>业务代码：结合框架特性</p> <p>http2</p> <p>window.performance：measure、mark</p> <h3 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h3> <p>XSS：信任用户输入且输出到页面时未转义，恶意用户的script（也可能是img的onload等）被渲染到正常用户的页面上执行。1、转义。2、meta：Content-Security-Policy（限制资源来源、请求的）</p> <p>CSRF：信任请求，第三方网站发起到cookie的本站请求。1、加上无法跨页获取的token(dom注入、setcookie手动取出)。2、cookie的SameSite</p> <p>？？dom注入的话，外域可以先ajax请求页面（一般页面不会有限制？）拿到dom，再拿token去发出恶意api？？</p> <p>SQL注入</p> <p>DDoS</p> <p>WAF</p> <h3 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h3> <p>ESM / CJS / AMD / CMD  / UMD</p> <h3 id="源码阅读"><a href="#源码阅读" class="header-anchor">#</a> 源码阅读</h3> <p>main/module</p> <p>package.json scripts</p> <p>main entry</p> <p>submodule</p> <h2 id="构建工具"><a href="#构建工具" class="header-anchor">#</a> 构建工具</h2> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h3> <h4 id="配置"><a href="#配置" class="header-anchor">#</a> 配置</h4> <p>多入口配置</p> <p>loader作用，对特定文件编译，流式</p> <p>plugin作用 ，全局作用，在complition不同阶段起作用</p> <h4 id="实现代码分割"><a href="#实现代码分割" class="header-anchor">#</a> 实现代码分割</h4> <p>splitChunk：单页：用test提取公共文件，减小文件体积，配合chunkhash，浏览器缓存公共文件；多入口：用minChunks提取出多次引用的文件</p> <p>ddl：ddl.config打包公共文件生成manifest，config引用这个manifest，不会对公共文件再次打包，提高编译速度</p> <h4 id="defineplugin"><a href="#defineplugin" class="header-anchor">#</a> definePlugin:</h4> <p>一般用于定义一些全局字段，和process.env（模仿node环境）。</p> <p>这些配置是在编译阶段静态直接转换，而非生成全局变量，比如模块中<code>process.env.NODE_ENV</code>编译后会直接被替换为定义的值，而<code>process.env['NODE' + '_ENV']</code>则不会</p> <h4 id="loader"><a href="#loader" class="header-anchor">#</a> loader</h4> <p>webpack中使用loader：</p> <div class="language- extra-class"><pre><code>config = {
	entry: '',
	output: {},
	module: {
		rules: [ // Rule[]
			{
				test: /xx.ext/,
				use: [ // Loader[]
					'loader-a',
					{
						loader: 'loader-b',
						option: {},
						query: {},
					}
				]
			}
		]
	}
}
</code></pre></div><p>编译过程中遇到匹配某rule的test的文件，会使用rule的use中设置的loader（可以是多个loader，从后往前）来加载这个文件。loader从node_module里的对应loader名调用。</p> <p>loader编写：</p> <div class="language- extra-class"><pre><code>module.export = function(content, map, meta) { 
	// do sth
	return newContent;
}
</code></pre></div><p>或者异步使用</p> <div class="language- extra-class"><pre><code>module.export = function(content, map, meta) { 
	// do sth
	this.callback(newContent);
}
</code></pre></div><p>babel-loader（文本loader）：</p> <p>得到js文件的文本内容content，将其解析成ast，重新组织语法，再生成新的字符串newContent返回</p> <p>file-loader（二进制loader）：</p> <p>文件内容content为二进制数据。引用webpack自带的loader-utils库，调用其<code>interpolateName</code>方法得到其hash名，调用<code>this.emitFile</code>把二进制content生成新file输出到output指定的目录下，最终结合config中的publicPath得到新file的可访问路径，最终组合成<code>module.exports = fileOutputPath</code>格式的数据返回</p> <h4 id="plugin"><a href="#plugin" class="header-anchor">#</a> plugin</h4> <p>plugin使用：</p> <div class="language- extra-class"><pre><code>	config = {
		entry: '',
		output: {},
		plugins: [
			new SomePlugin(options),
		],
	}
</code></pre></div><p>plugin编写：</p> <div class="language- extra-class"><pre><code>class {
	constructor(options) {
		// 拿到用户定义的options
	}
	apply(compiler) {
		// 插件安装时调用一次，拿到compiler对象（提供webpack全局配置信息）
		// 可以从compiler的hooks回调拿到compilation对象（每次文件变动重新生成，提供本次资源相关信息）
		// 在compiler和compilation的各类hooks（基于tapable）绑定自定义事件
	}			
}
</code></pre></div><h3 id="rollup"><a href="#rollup" class="header-anchor">#</a> rollup</h3> <p>适合库而非应用（app），treeshaking，缺少懒加载</p> <h3 id="webpack-rollup"><a href="#webpack-rollup" class="header-anchor">#</a> webpack&amp;rollup</h3> <p>treeshaking + 去除无用if代码</p> <h3 id="gulp"><a href="#gulp" class="header-anchor">#</a> gulp</h3> <p>流式任务</p> <h3 id="babel"><a href="#babel" class="header-anchor">#</a> babel</h3> <p>polyfill关系：babel只转语法，polyfill拓展原型和全局对象</p> <p>原理：text =&gt; tokens =&gt; ast =&gt; ast(transformed) =&gt; text</p> <p>browser版：监听DOMContentLoaded，选取所有<code>type=&quot;text/babel&quot;</code>（带src的ajax加载），编译结果新建script设置script.text后append到head</p> <h2 id="html"><a href="#html" class="header-anchor">#</a> HTML</h2> <h3 id="input有哪些attribute"><a href="#input有哪些attribute" class="header-anchor">#</a> input有哪些attribute</h3> <h3 id="label作用"><a href="#label作用" class="header-anchor">#</a> label作用</h3> <h3 id="script标签-defer、async"><a href="#script标签-defer、async" class="header-anchor">#</a> script标签 defer、async</h3> <h3 id="blob-、dataurl"><a href="#blob-、dataurl" class="header-anchor">#</a> blob 、dataURL</h3> <h4 id="blob"><a href="#blob" class="header-anchor">#</a> blob</h4> <p>提供内存地址，数据保存在页面内存</p> <p><code>new Blob([...data], {...options})</code> 自动垃圾回收</p> <p><code>URL.createObjectURL(file)</code> 用URL.revokeObjectURL手动回收</p> <h4 id="dataurl"><a href="#dataurl" class="header-anchor">#</a> dataURL</h4> <p>用编码（比如base64字符串）显式表示文件</p> <p><code>new FileReader().readAsDataURL</code></p> <h2 id="css"><a href="#css" class="header-anchor">#</a> CSS</h2> <h3 id="float、flex、gird"><a href="#float、flex、gird" class="header-anchor">#</a> float、flex、gird</h3> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <p>独立容器，不影响外部</p> <p>BFC：overflow: hidden / float: left / display: inline-block</p> <p>特性：外部margin不合并/内部清除浮动（高度不塌陷）/外部清除浮动（文字不环绕）</p> <h3 id="无限滚动的轮播图"><a href="#无限滚动的轮播图" class="header-anchor">#</a> 无限滚动的轮播图</h3> <h3 id="左边定宽右边自适应多种实现"><a href="#左边定宽右边自适应多种实现" class="header-anchor">#</a> 左边定宽右边自适应多种实现</h3> <p>flex、calc、absolute</p> <h3 id="css变量"><a href="#css变量" class="header-anchor">#</a> CSS变量</h3> <h3 id="retina-画0-5px"><a href="#retina-画0-5px" class="header-anchor">#</a> retina 画0.5px</h3> <p>dpr（window.devicePixelRatio）+ <code>&lt;mete name=&quot;viewport&quot;/&gt;</code>(initial-scale)</p> <h3 id="盒模型"><a href="#盒模型" class="header-anchor">#</a> 盒模型</h3> <h2 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h2> <h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <p>prop</p> <p>emit</p> <p>bus、vuex等第三方数据管理库</p> <p>watch</p> <p>ref</p> <p>broadcast+dispatch（vue1）</p> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <h3 id="vuex-数据流"><a href="#vuex-数据流" class="header-anchor">#</a> vuex 数据流</h3> <p>action异步，mutation同步</p> <p>弊端：action意义不大</p> <h3 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> $nextTick</h3> <p>作用</p> <p>可否用setTimeout替代</p> <h3 id="v-if-v-show"><a href="#v-if-v-show" class="header-anchor">#</a> v-if &amp; v-show</h3> <p>用法，场景</p> <h3 id="父调子"><a href="#父调子" class="header-anchor">#</a> 父调子</h3> <p>ref、props+watch</p> <h3 id="实现tel格式的input-133-1234-1234"><a href="#实现tel格式的input-133-1234-1234" class="header-anchor">#</a> 实现tel格式的input（133 1234 1234）</h3> <h3 id="从data改变到view变化经历的过程"><a href="#从data改变到view变化经历的过程" class="header-anchor">#</a> 从data改变到view变化经历的过程</h3> <p>初始化 为obj每个属性建立getter/setter，挂载新dep</p> <p>初次渲染 利用触发getter绑定watcher到dep</p> <p>数据变化 setter触发dep中的watcher，watcher触发更新</p> <p>更新 virtual dom，snabbdom diff，patch</p> <h3 id="watcher和virtual-dom结合"><a href="#watcher和virtual-dom结合" class="header-anchor">#</a> watcher和virtual dom结合</h3> <p>vue1: 每条data一个watcher，绑定到data对应的dom，data变化直接更新到dom，粒度细
vue2的vdom：每条data一个watcher，每个组件也一个watcher，data只绑定到组件，data变化通知组件的watcher重新渲染，粒度适中</p> <h3 id="runtime-with-compiler"><a href="#runtime-with-compiler" class="header-anchor">#</a> runtime &amp; with-compiler</h3> <h3 id="slots"><a href="#slots" class="header-anchor">#</a> slots</h3> <p>slot-scope用法（子：<code>&lt;slot name=&quot;a&quot; :params=&quot;params&quot;/&gt;</code>，父：<code>&lt;div slot=&quot;a&quot; slot-scope=&quot;p&quot;&gt;&lt;/div&gt;</code>）</p> <p>$slots返回值（render函数）</p> <h3 id="css-scope"><a href="#css-scope" class="header-anchor">#</a> css scope</h3> <h3 id="mixins"><a href="#mixins" class="header-anchor">#</a> mixins</h3> <h3 id="vue-directive"><a href="#vue-directive" class="header-anchor">#</a> Vue.directive</h3> <h3 id="大列表优化"><a href="#大列表优化" class="header-anchor">#</a> 大列表优化</h3> <h3 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h3> <p>生命周期只执行到created且不能有浏览器独有api</p> <p>###dom diff</p> <p>基于snabbdom，头尾双指针，o(n)，牺牲对比精度换取时间(更贴近数组实际操作而非完全乱序)，有key的情况</p> <h3 id="源码学习"><a href="#源码学习" class="header-anchor">#</a> 源码学习</h3> <h4 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h4> <p>core/instance 定义Vue，定义原型属性</p> <p>core/globalAPI 定义静态属性</p> <p>platform 平台化包装导出（runtime &amp; with-compiler）</p> <p>core/lifecycle  初始化实例的生命周期，callHook</p> <p>架构是随着项目发展调整的，commit记录</p> <h4 id="dep-target"><a href="#dep-target" class="header-anchor">#</a> dep.target</h4> <p>正常：data监听setter和绑定dep，编译模板时AST解析调用了哪些data属性，去给它们添加dep</p> <p>Vue：data还监听了getter，编译模板时会触发getter，getter里通过target判断是否处于编译中，是的话把target指向的watcher添加到对应的dep，编译前后会改写target</p> <h4 id="nexttick-2"><a href="#nexttick-2" class="header-anchor">#</a> nextTick</h4> <p>（内部实现micro：Promise，macro：MessageChannel、setTimeout）</p> <p>定义microFunc macroFunc</p> <p>执行nextTick时，推入callbacks并触发一次（根据pending变量判断）在下轮执行flushCallbacks</p> <p>flushCallbacks清空callbacks，依次执行callbacks（先清空来保证出现nextTick嵌套时的执行次序）</p> <p>数据变动优先使用micro，可以在一轮事件循环内改变完data，只触发一次重渲染</p> <h4 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h4> <p>vue中的computed具有缓存和懒计算。</p> <p>实现：</p> <p>每个computed属性会建立一个watcher对应。</p> <p>在被使用时（getter触发时）进入computedGetter，根据watcher.dirty的值 true/false 决定 重新计算/返回缓存。</p> <p>第一次被使用时，默认watcher.dirty为true，触发computed计算，并收集计算中用到的依赖（把自身关联到依赖的watcher通知列表），并存下本次计算的value值。</p> <p>当有依赖发生改动时，该computed的watcher.dirty会被设置为true，下次该computed被使用时就会被重新计算并缓存value，再把dirty重置为false。</p> <h3 id="vue-react差异"><a href="#vue-react差异" class="header-anchor">#</a> vue/react差异</h3> <p>写法：webcomponent / all in js</p> <p>MVC：数据层侵入 / 纯视图</p> <p>数据管理：便捷的v-model、computed / 单向、immutable的数据流</p> <p>库：官方库 简单 / 第三方库 灵活 复杂</p> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <p>###组件通信</p> <p>prop,ref,context,数据管理(redux, mobx, rx)</p> <p>###生命周期</p> <p>新建： constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</p> <p>卸载：componentWillUnmount</p> <p>更新：componentWillReceiveProps -&gt; shouldComponentUpdate-&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p> <p>setState：shouldComponentUpdate-&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p> <p>forceUpdate：componentWillUpdate -&gt; render -&gt; componentDidUpdate</p> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> redux</h3> <p>redux实现：</p> <p>combineReducers把多个reducer函数整合成一个大reducer函数，createStore(reducer)初始化store。</p> <p>每次调用store.dispatch(action)，该action都会通过这个大reducer（相当于通过每个子reducer），来得到各部分的新state，最后整合得到大state。</p> <p>结合react-redux：顶层state变化时，使用connect的组件会将它通过state获取到的props作前后浅比较，若有变化，该容器层props改变触发组件render，而非一有state变化就render</p> <p>改进点？：action和reducer繁琐；action和reducer需要匹配自定义type来关联，而不是自动关联。</p> <h3 id="fiber"><a href="#fiber" class="header-anchor">#</a> fiber</h3> <p>任务分片，任务优先级，基于requestIdleCallback、requestAnimationFrame</p> <h3 id="context"><a href="#context" class="header-anchor">#</a> context</h3> <p>16.3前后api对比</p> <p>解决：不符合分形、无法穿透shouldUpdateComponent</p> <h3 id="hook"><a href="#hook" class="header-anchor">#</a> hook</h3> <h3 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h3> <p>一次DOM reconciliation调用setState多次，state非立刻变化</p> <p>transaction模型,batchedUpdates(ReactDOM.unstable_batchedUpdates)</p> <p>###pureComponent</p> <p>和普通component差异：</p> <p>自动添加shouldUpdateComponent的判断，对变化前后的props和state进行浅比较返回bool，来决定要不要走render</p> <h3 id="immutable"><a href="#immutable" class="header-anchor">#</a> immutable</h3> <p>优势：</p> <p>命名：$$</p> <p>一个有趣的现象：</p> <div class="language- extra-class"><pre><code>&lt;div&gt;
  {
    immutable.fromJS([{ a: 1 }, 2, 3]) // 渲染成a123
  }
&lt;/div&gt;
&lt;div&gt;
  {
    [{ a: 1 }, 2, 3] // 报错
  }
&lt;/div&gt;
</code></pre></div><p>因为渲染时递归判断元素是否为简单值（作为text节点渲染）？是否为ReactElement实例（作为原生DOM或者组件渲染）？是否为数组（是的话调用其<code>Symbol.iterator</code>得到其子集，继续对子集元素递归以上步骤）？都为否的话则无法渲染。
<code>{a: 1}</code>在immutable化后，是一个布署了iterator接口的Map，遍历结构类似<code>[[&quot;a&quot;, 1]]</code>，所以可以渲染成文本节点<code>a</code> 和<code>1</code>；而Object类型的<code>{a: 1}</code>则无法满足以上条件。</p> <h2 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h2> <h3 id="e2e、unit"><a href="#e2e、unit" class="header-anchor">#</a> e2e、unit</h3> <p>karma、macha</p> <h2 id="node"><a href="#node" class="header-anchor">#</a> Node</h2> <h3 id="进程模块"><a href="#进程模块" class="header-anchor">#</a> 进程模块</h3> <p>进程通信
exec：shell，一次性数据
spawn：stream管道，stdout
fork：特殊的spawn（node），IPC管道，可用process.send(data)和process.on('message', callback)通信</p> <h3 id="package-json"><a href="#package-json" class="header-anchor">#</a> package.json</h3> <h4 id="npm-install"><a href="#npm-install" class="header-anchor">#</a> NPM install</h4> <p><code>npm i</code>：安装pkg所有dependencies，devdependencies
<code>npm i [module] [-S/-D]</code>：安装[module]到此目录下的node_modules并记录到pkg
<code>-g</code>：安装到全局node_modules
<code>npm uninstall [module] [-g]</code>：卸载</p> <h4 id="scripts"><a href="#scripts" class="header-anchor">#</a> scripts</h4> <div class="language- extra-class"><pre><code>scripts: {
  &quot;test&quot;: &quot;node bin/test.js --hot&quot;
}
</code></pre></div><p>通过<code>npm run test</code>来快捷执行<code>node bin/test.js --hot</code>，script中process.argvs读取命令行参数</p> <h4 id="版本号"><a href="#版本号" class="header-anchor">#</a> 版本号</h4> <p><code>^1.2.3</code>：可兼容到1.x.x
<code>~1.2.3</code>：可兼容到1.2.x</p> <h4 id="bin"><a href="#bin" class="header-anchor">#</a> bin</h4> <p>shell方式运行，bin如下设置</p> <div class="language- extra-class"><pre><code>bin: {
  &quot;my-bin&quot;: &quot;bin/my-bin.js&quot;
}
</code></pre></div><p><code>my-bin.js</code>中的文件首行加上<code>#!/usr/bin/env node</code>表示以node环境运行</p> <p>install之后，my-bin.js会被复制到<code>node_modules/.bin</code>下成为shell脚本，在cmd中直接<code>node_modules/.bin/my-bin [--params]</code>（或者全局安装后<code>my-bin [--params]</code>）来运行</p> <h3 id="爬虫"><a href="#爬虫" class="header-anchor">#</a> 爬虫</h3> <p>历史、当前</p> <h2 id="pwa"><a href="#pwa" class="header-anchor">#</a> PWA</h2> <p>对象：</p> <p>作用域：sw.js相对路径下的client受控、该域同一时间只有一个sw</p> <p>serviceWorker更新时机（检查sw，若改变则重新install）：页面初始化、手动reg.update()、触发了push等事件且24h未更新</p> <p>skipWaiting：</p> <p>不等老sw的client全部卸载，直接激活新sw</p> <p>claim：</p> <p>控制当前作用域还未被控制的client ？？</p> <p>install：注册，一般cache在此时操作</p> <p>active：激活</p> <p>fetch：等sw active后才受控</p> <p>缓存：</p> <p>serviceWorker监听client的fetch，从cache判断命中</p> <p>消息推送：</p> <p>可视化消息</p> <p>register返回registration对象，在此对象subscribe来注册</p> <p>serviceWork监听push，调用registration的showNotification展示消息，client.postMessage推送给页面</p> <h2 id="graphql"><a href="#graphql" class="header-anchor">#</a> GraphQL</h2> <p>query</p> <div class="language- extra-class"><pre><code>query {
  viewer { // 对象
    name, // string数据
    respos (first: 10, after: &quot;cursorString&quot;) { // 对象数据，需要另开connection，返回respo列表，first：列表数量；after：分页标记；以及其他支持的查询条件
      edges {
        cursor // 分页标记
        node { // 每条数据的结构
          name
        }
      }
      pageInfo { // 分页相关信息
        hasNextPage
      }
    } 
    respo (name: &quot;aaa&quot;) { // connection，返回指定name的respo或者null
      createdAt
    }
  }
}
variables { // 定义变量。在上面用$something使用
  &quot;something&quot;: {
    &quot;name&quot;: &quot;bbb&quot;
  }
}
</code></pre></div><p>mutation</p> <h2 id="experience"><a href="#experience" class="header-anchor">#</a> experience</h2> <h4 id="产品、技术平衡"><a href="#产品、技术平衡" class="header-anchor">#</a> 产品、技术平衡</h4> <h4 id="推动技术、产品抽象"><a href="#推动技术、产品抽象" class="header-anchor">#</a> 推动技术、产品抽象</h4> <p>弹框</p> <p>token</p> <h4 id="项目架构、前后分离"><a href="#项目架构、前后分离" class="header-anchor">#</a> 项目架构、前后分离</h4> <p>背景：无leader、无架构、边尝试边修改</p> <p>问题：每个系统重复搭建，且架构不一</p> <p>改进：</p> <p>基于vue/react+webpack抽象出通用系统模板，封装token、枚举值等，多套打包配置，及时改进</p> <p>新增活动系统，按需打包，各项目隔离。cli启动，自定义webpack打包前后逻辑</p> <p>思考：架构是让团队专注业务开发。适时改进，贴近业务</p> <h4 id="团队分工"><a href="#团队分工" class="header-anchor">#</a> 团队分工</h4> <p>背景：历史原因，项目架构不一，放养不限制风格，人员固定</p> <p>问题：项目风格个人化，别人不易接手</p> <p>改进：制定代码规范，均匀分配需求，写技术文档</p> <p>思考：</p> <p>1、团队像项目，低耦合可拆卸，才能长远发展</p> <p>2、制定一个没大错的规范比没有好</p> <p>3、写的代码是给别人看的，对自己也是一种监督</p> <p>4、分工有度，系统负责人，减少技术债</p> <h4 id="开发流程"><a href="#开发流程" class="header-anchor">#</a> 开发流程</h4> <p>背景：开发规范、产品规范薄弱</p> <p>问题：甩锅接口，prd过简，团队开发效率低，延期率高</p> <p>改进：推进swagger+mock，推进产品规范（抽离通用组件，一致性），git workflow &amp; 自动化发布</p> <p>思考：规范推动效率，充足的时间才能保证项目质量</p> <h4 id="如何写基础组件"><a href="#如何写基础组件" class="header-anchor">#</a> 如何写基础组件</h4> <p>定义好输入=&gt;输出，中间的复杂变化交给代码</p> <p>满足固定逻辑：
取舍有度，不能无限制灵活（table表格）</p> <p>易拓展：
不仅是枚举出来的选项，只要满足规定就可用（slot、函数），给默认值
降低耦合性、抛出必要信息给外部业务处理（input联想输入里的http请求）</p> <p>代码质量：
缓存优化、加载卸载</p> <h2 id="加密"><a href="#加密" class="header-anchor">#</a> 加密</h2> <h3 id="rsa非对称加密"><a href="#rsa非对称加密" class="header-anchor">#</a> RSA非对称加密</h3> <h4 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h4> <p>密钥a：e（指数），n（模）
密钥b：d（指数），n（模）</p> <p>用密钥a把M加密为C：C = M ** e (mod n)
用密钥b把C还原为M：M = C ** d (mod n)</p> <p>也可以反过来用密钥b加密，密钥a还原，从数学上密钥a、b完全可以交换使用。但在实际运用中，一般会生成一个指数较小的（或者固定的）数作为公钥开放（客户端使用起来更方便），指数较大的数作为私钥。如果将它们交换，相当于用一个指数较小的数作为私钥，较容易被反推出来，不安全。</p> <h4 id="密钥对生成"><a href="#密钥对生成" class="header-anchor">#</a> 密钥对生成</h4> <p>生成e，d，n过程：</p> <p>1、选取两个足够大的素数：p、q</p> <p>2、n = p * q</p> <p>3、m = (p - 1) * (q - 1)</p> <p>4、找一个与m互质的数e，且1 &lt; e &lt; m</p> <p>5、找出d，使得d * e (mod m) = 1</p> <p>6、生成完毕，密钥a：(e, n)，密钥b：(d, n)</p> <h4 id="安全性"><a href="#安全性" class="header-anchor">#</a> 安全性</h4> <p>安全性是基于：大素数分解困难。在这个条件成立的前提下，通过已知的大素数n难以反推出p、q，所以也难以推出e、d，因此密钥a、b虽然可以相互加密解密，但算出另一密钥是困难的。</p> <h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <p>生成密钥对</p> <p>1、选取两个素数 p = 3 ，q = 11（为方便举例选取了较小的素数）</p> <p>2、n = p * q = 3 * 11 = 33</p> <p>3、m = (p - 1) * (q - 1) = (3 - 1) * (11 - 1) = 20</p> <p>4、从比m小的数中找出一个与m互质的数 e = 3</p> <p>5、可以通过穷举法，d从1开始递增，试出满足条件的最小的d = 7</p> <p>6、得出一对密钥：密钥a：(3, 33)，密钥b：(7, 33)</p> <p>对'rsa'这个字符串加密</p> <p>1、对‘rsa’进行数字化转化，'r'，‘s'，’a'可以转化成其对应字母表次序：18、19、1</p> <p>2、用密钥a加密：</p> <p>r =&gt; 18 =&gt; 18 ** 3 % 33 =&gt; 24</p> <p>s =&gt; 19 =&gt; 19 ** 3 % 33 =&gt; 28</p> <p>a =&gt; 1 =&gt; 1 ** 3 % 33 =&gt; 1</p> <p>加密后：['r', 's', 'a'] =&gt; [24, 28, 1]</p> <p>对加密后的[24, 28, 1]进行还原</p> <p>1、用密钥b解密</p> <p>24 =&gt; 24 ** 7 % 33 =&gt; 18 =&gt; r</p> <p>28 =&gt; 28 ** 7 % 33 =&gt; 19 =&gt; s</p> <p>1 =&gt; 1 ** 7 % 33 =&gt; 1 =&gt; a</p> <p>得出结果'rsa'</p> <h2 id="工程化"><a href="#工程化" class="header-anchor">#</a> 工程化</h2> <h3 id="规范、人员分工"><a href="#规范、人员分工" class="header-anchor">#</a> 规范、人员分工</h3> <h3 id="模块化-2"><a href="#模块化-2" class="header-anchor">#</a> 模块化</h3> <h3 id="自动化"><a href="#自动化" class="header-anchor">#</a> 自动化</h3></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.541eff33.js" defer></script><script src="/assets/js/2.df51b1a1.js" defer></script><script src="/assets/js/19.314c4b0a.js" defer></script>
  </body>
</html>
