(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{450:function(s,t,o){"use strict";o.r(t);var v=o(54),a=Object(v.a)({},(function(){var s=this,t=s.$createElement,o=s._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[o("h1",{attrs:{id:"hooks-vs-class"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#hooks-vs-class"}},[s._v("#")]),s._v(" Hooks VS Class")]),s._v(" "),o("p",[s._v("React16.8为组件编写提供了新的hooks写法。")]),s._v(" "),o("p",[s._v("hooks组件相比原来的class组件的优点在于：")]),s._v(" "),o("ol",[o("li",[s._v("扩展了组件的定义，使得组件不再局限于UI组件，也可以是逻辑组件")])]),s._v(" "),o("p",[s._v("组件返回参数可以是普通参数，支持了"),o("strong",[s._v("和view关联的逻辑")]),s._v("的复用。这个复用非UI复用（class组件），也非逻辑复用（抽象出JS函数）。")]),s._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[s._v("基于1的基础组合出来的组件，各个参数的来源更清晰")])]),s._v(" "),o("p",[s._v("复用逻辑时直接把参数定义和来源写在组件内，而非原来的HOC组件（在Vue中是mixins）嵌套，参数来源得从上游组件去找。")]),s._v(" "),o("ol",{attrs:{start:"3"}},[o("li",[s._v("相关逻辑聚合")])]),s._v(" "),o("p",[s._v("比如bind和unbind的配对代码可以成对地写在更近的位置，而非分散在各个生命周期里。")]),s._v(" "),o("ol",{attrs:{start:"4"}},[o("li",[s._v("避免this问题")])]),s._v(" "),o("p",[s._v("避免了组件内this的使用，"),o("strong",[s._v("写法上")]),s._v("就像一个纯函数一样，不依赖于运行的上下文（虽然只是把复杂度隐藏在hooks内部，上下文交给了内部逻辑去处理）。")])])}),[],!1,null,null,null);t.default=a.exports}}]);