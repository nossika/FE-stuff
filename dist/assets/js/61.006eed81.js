(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{458:function(t,e,a){"use strict";a.r(e);var s=a(54),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-vs-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-vs-react"}},[t._v("#")]),t._v(" Vue vs React")]),t._v(" "),a("h2",{attrs:{id:"相同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同"}},[t._v("#")]),t._v(" 相同")]),t._v(" "),a("p",[t._v("组件化框架，隔离DOM操作")]),t._v(" "),a("h2",{attrs:{id:"生态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生态"}},[t._v("#")]),t._v(" 生态")]),t._v(" "),a("p",[t._v("Vue的配套以官方库为主，选择成本低，项目风格较一致。")]),t._v(" "),a("p",[t._v("React以社区为主，灵活选择，可根据业务特性更多地定制化。")]),t._v(" "),a("h2",{attrs:{id:"设计哲学"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计哲学"}},[t._v("#")]),t._v(" 设计哲学")]),t._v(" "),a("p",[t._v("Vue对开发者友好，流式数据，提供了更多便捷API来方便业务开发，如v-model、computed、class名组装、scoped css等。")]),t._v(" "),a("p",[t._v("组件类web component设计，声明式API，代码量低不过有额外理解成本。")]),t._v(" "),a("p",[t._v("React核心更简洁，函数式编程，immutable。")]),t._v(" "),a("p",[t._v("组件all in JS，额外学习JSX即可，逻辑都是直观的JS。")]),t._v(" "),a("p",[t._v("React内部实现更纯粹，不依赖语言特性，更贴合最小表达力原则。比如基于事务实现批量state更新而非setTimeout，比如不用getter/setter做数据劫持。")]),t._v(" "),a("h2",{attrs:{id:"内部原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部原理"}},[t._v("#")]),t._v(" 内部原理")]),t._v(" "),a("p",[t._v("Vue的核心是数据劫持+依赖关联。提前绑定好数据和组件的关联关系，数据的变动只会引发关联组件的render和DOM diff，计算只在局部进行。")]),t._v(" "),a("p",[t._v("这种关联可以理解为一种空间换时间，组件初始化时多花时间和空间来建立关联关系，后续更新时则免于判断更新影响了哪些组件。关联的粒度到组件级别是一个折中的优化，Vue1则是直接关联到精确的DOM片段，连DOM diff都不需要，更新效率更高，但其初始化时间和内存占用也更差。")]),t._v(" "),a("p",[t._v("React思想是immutable+函数式。某个组件发生数据变动，则引发整个组件和其子孙组件（除非某个组件用了memo或者shouldupdate的优化，此路径会中断）都会render并整体DOM diff。")]),t._v(" "),a("p",[t._v("因此Vue的项目，框架的实现使其性能下限更高一些。")])])}),[],!1,null,null,null);e.default=v.exports}}]);