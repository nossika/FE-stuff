(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{420:function(t,v,_){"use strict";_.r(v);var a=_(54),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"编程语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编程语言"}},[t._v("#")]),t._v(" 编程语言")]),t._v(" "),_("h2",{attrs:{id:"脚本语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#脚本语言"}},[t._v("#")]),t._v(" 脚本语言")]),t._v(" "),_("p",[t._v("『脚本语言』设计的初衷是为了方便快捷地执行一些批量命令，所以被设计为可以直接运行，边解释边执行；而非像传统语言，需要在运行前先编译，因此脚本语言也被称为解释型语言。但实际上很多脚本语言也有编译环节，只不过编译是被放在解释器里自动执行了。")]),t._v(" "),_("h2",{attrs:{id:"动-静态、强-弱类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动-静态、强-弱类型"}},[t._v("#")]),t._v(" 动/静态、强/弱类型")]),t._v(" "),_("p",[t._v("这二者是描述语言类型的不同维度。")]),t._v(" "),_("p",[t._v("静态：编译时（或运行前）就已经确定变量类型，编译时会对变量做类型检查，不会在运行阶段发生因类型导致的错误。变量类型可以是通过显式声明（如Java）或是隐式推导（如Haskell）来确定。")]),t._v(" "),_("p",[t._v("动态：变量类型不确定，可以在运行时被改变，因类型导致的错误是运行错误。")]),t._v(" "),_("p",[t._v("强类型：不允许隐式类型转换。")]),t._v(" "),_("p",[t._v("弱类型：允许隐式类型转换。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[t._v("动态")]),t._v(" "),_("th",[t._v("静态")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("强类型")]),t._v(" "),_("td",[t._v("Python")]),t._v(" "),_("td",[t._v("Java/Go/Haskell")])]),t._v(" "),_("tr",[_("td",[t._v("弱类型")]),t._v(" "),_("td",[t._v("JS/PHP")]),t._v(" "),_("td",[t._v("C/C++")])])])]),t._v(" "),_("h2",{attrs:{id:"汇编语言与机器码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#汇编语言与机器码"}},[t._v("#")]),t._v(" 汇编语言与机器码")]),t._v(" "),_("p",[t._v("『机器码』是可被硬件识别和执行的由0和1组成的一串指令，不论是编写程序时用的是何种语言，最终都是被翻译成机器码来执行。")]),t._v(" "),_("p",[t._v("编程语言有高低级之分，越低级的语言越接近机器的指令，可以更直接地控制程序运行，同时可读性也更差；越高级的语言越接近人类的表达方式，抽象程度更高，可读性也更好。")]),t._v(" "),_("p",[t._v("『汇编语言』是低级语言，通过汇编程序可以直接被翻译为对应的机器码，一般每条语句会与一条机器指令一一对应。")])])}),[],!1,null,null,null);v.default=r.exports}}]);