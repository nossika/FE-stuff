(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{462:function(t,e,a){"use strict";a.r(e);var r=a(54),d=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"原理相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理相关"}},[t._v("#")]),t._v(" 原理相关")]),t._v(" "),a("h2",{attrs:{id:"从data改变到view变化经历的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从data改变到view变化经历的过程"}},[t._v("#")]),t._v(" 从data改变到view变化经历的过程")]),t._v(" "),a("p",[t._v("初始化 为obj每个属性建立getter/setter，挂载新dep")]),t._v(" "),a("p",[t._v("初次渲染 利用触发getter绑定watcher到dep")]),t._v(" "),a("p",[t._v("数据变化 setter触发dep中的watcher，watcher触发更新")]),t._v(" "),a("p",[t._v("更新 virtual dom，snabbdom diff，patch")]),t._v(" "),a("h2",{attrs:{id:"dom-diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-diff"}},[t._v("#")]),t._v(" DOM-diff")]),t._v(" "),a("p",[t._v("Vue分离了diff和patch的逻辑，先基于vnode进行diff，再根据diff结果进行实际的patch操作，patch在不同的终端上有不同实现，但diff是统一的逻辑。")]),t._v(" "),a("p",[t._v("传统DOM-diff的时间复杂度为O(n"),a("sup",[t._v("3")]),t._v(")")]),t._v(" "),a("ul",[a("li",[t._v("只在新老DOM的同一层级的节点比较，且对每个节点只遍历一次。实际业务中很少有跨层级移动节点的情况。")]),t._v(" "),a("li",[t._v("新老节点如果类型/key不同，直接当做新建节点处理，不会再继续往下比较。大部分情况下，不同节点有不同内部的结构。")])]),t._v(" "),a("p",[t._v("基于此两点优化算法后，DOM-diff的时间复杂度为O(n)，牺牲对比的准确性来换取性能（有时即使原节点存在，也会因没匹配到而重新创建）。")]),t._v(" "),a("h3",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[t._v("#")]),t._v(" diff算法")]),t._v(" "),a("p",[t._v("vue中的diff算法基于开源的snabbdom修改而来，实现如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在新老vnode列表的头尾部各设置1个指针，总共4个指针：newStart/newEnd/oldStart/oldEnd")])]),t._v(" "),a("li",[a("p",[t._v("对这4个指针指向的vnode进行如下对比")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如果newStart和oldStart的vnode同类型（包括key、tag等），那么复用oldStart对应的节点，对其递归diff，然后newStart++、oldStart++")])]),t._v(" "),a("li",[a("p",[t._v("如果newEnd和oldEnd的vnode同类型，那么复用oldEnd对应的节点，对其递归diff，然后newEnd--、oldEnd--")])]),t._v(" "),a("li",[a("p",[t._v("如果newStart和oldEnd的vnode同类型，那么复用oldEnd对应的节点，并将其移动到oldStart对应的节点之前，对其递归diff，然后newStart++、oldEnd--")])]),t._v(" "),a("li",[a("p",[t._v("如果newEnd和oldStart的vnode同类型，那么复用oldStart对应的节点，并将其移动到oldEnd对应的节点之后，对其递归diff，然后newEnd--、oldStart++")])]),t._v(" "),a("li",[a("p",[t._v("如果newStart的vnode有key值且能找到到key对应的oldVnode，且同类型，那么复用oldVnode对应的节点，并将其移动到oldStart对应的节点之前，对其递归diff，然后newStart++")])]),t._v(" "),a("li",[a("p",[t._v("如果上述条件都不成立，那么直接根据newStart的vnode创建一个新节点，插入到oldStart对应的节点之前，然后newStart++")])])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("重复步骤2，直到oldStart > oldEnd 或者 newStart > newEnd 时，进入步骤4")])]),t._v(" "),a("li",[a("p",[t._v("此时有两种情况")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如果是oldStart > oldEnd，那么将newStart和newEnd之间的vnode都创建为新节点，插入到oldEnd之前")])]),t._v(" "),a("li",[a("p",[t._v("如果是newStart > newEnd，那么将oldStart和oldEnd之间的节点都作为废弃节点删除掉")])])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("整个diff操作完成")])]),t._v(" "),a("h3",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[t._v("#")]),t._v(" 例子")]),t._v(" "),a("p",[t._v("old: a b c d e")]),t._v(" "),a("p",[t._v("new: b c d f")]),t._v(" "),a("p",[t._v("todo")]),t._v(" "),a("h2",{attrs:{id:"响应式更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式更新"}},[t._v("#")]),t._v(" 响应式更新")]),t._v(" "),a("p",[t._v("监听对象变化：")]),t._v(" "),a("p",[t._v("对对象各个key递归使用Object.defineProperty监听其getter和setter。")]),t._v(" "),a("p",[t._v("监听数组变化：")]),t._v(" "),a("p",[t._v("改写数组的原型上的push、pop、reverse等方法，监听数组api的调用。但不监听直接对数组下标修改的变化（"),a("code",[t._v("arr[1]=2")]),t._v("），其实同样可以通过defineProperty的方式来监听，arr当做对象，下标当做key，但出于性能考虑没有这么实现。")]),t._v(" "),a("p",[t._v("Proxy：")]),t._v(" "),a("p",[t._v("Vue3用Proxy来改写响应式逻辑，Proxy能把对象和数组的监听统一处理，也可监听到通过数组下标作的修改，省去对数组的特殊操作。")]),t._v(" "),a("h3",{attrs:{id:"watcher"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watcher"}},[t._v("#")]),t._v(" watcher")]),t._v(" "),a("p",[t._v("data每个prop的setter与组件的watcher关联，prop变化时，通知组件的watcher来重新执行render。后面再对新老render生成的vdom进行diff，来更新dom。")]),t._v(" "),a("p",[t._v("Vue1做法: 在初次编译时遍历dom节点，新建watcher将dom节点与data里对应的prop的setter关联，prop变化时，通过此watcher直接更新对应的dom节点。此方法dom更新效率更高（直接更新目标dom，省去了diff过程），但初始化时间长（创建watcher与dom的一一关联）、占用内存高（内存里保留了dom的引用）、watcher和浏览器环境的dom耦合。")]),t._v(" "),a("h3",{attrs:{id:"dep-target"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dep-target"}},[t._v("#")]),t._v(" dep.target")]),t._v(" "),a("p",[t._v("一般做法：data监听setter和绑定dep，编译模板时AST解析调用了哪些data属性，去给它们添加dep")]),t._v(" "),a("p",[t._v("Vue做法：data还监听了getter，编译模板时会触发getter，getter里通过target判断是否处于编译中，是的话把target指向的watcher添加到对应的dep，编译前后会改写target")]),t._v(" "),a("h3",{attrs:{id:"computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),a("p",[t._v("vue中的computed具有缓存和懒计算。")]),t._v(" "),a("p",[t._v("实现：")]),t._v(" "),a("p",[t._v("每个computed属性会建立一个watcher对应。")]),t._v(" "),a("p",[t._v("在被使用时（getter触发时）进入computedGetter，根据watcher.dirty的值 true/false 决定 重新计算/返回缓存。")]),t._v(" "),a("p",[t._v("第一次被使用时，默认watcher.dirty为true，触发computed计算，并收集计算中用到的依赖（把自身关联到依赖的watcher通知列表），并存下本次计算的value值。")]),t._v(" "),a("p",[t._v("当有依赖发生改动时，该computed的watcher.dirty会被设置为true，下次该computed被使用时就会被重新计算并缓存value，再把dirty重置为false。")]),t._v(" "),a("h2",{attrs:{id:"nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),a("p",[t._v("（内部实现micro：Promise，macro：MessageChannel、setTimeout）")]),t._v(" "),a("p",[t._v("定义microFunc macroFunc")]),t._v(" "),a("p",[t._v("执行nextTick时，推入callbacks并触发一次（根据pending变量判断）在下轮执行flushCallbacks")]),t._v(" "),a("p",[t._v("flushCallbacks清空callbacks，依次执行callbacks（先清空来保证出现nextTick嵌套时的执行次序）")]),t._v(" "),a("p",[t._v("数据变动优先使用micro，可以在一轮事件循环内改变完data，只触发一次重渲染")]),t._v(" "),a("h2",{attrs:{id:"源码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码结构"}},[t._v("#")]),t._v(" 源码结构")]),t._v(" "),a("p",[t._v("core/instance 定义Vue，定义原型属性")]),t._v(" "),a("p",[t._v("core/globalAPI 定义静态属性")]),t._v(" "),a("p",[t._v("platform 平台化包装导出（runtime & with-compiler）")]),t._v(" "),a("p",[t._v("core/lifecycle  初始化实例的生命周期，callHook")]),t._v(" "),a("h3",{attrs:{id:"runtime-with-compiler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime-with-compiler"}},[t._v("#")]),t._v(" runtime & with-compiler")])])}),[],!1,null,null,null);e.default=d.exports}}]);