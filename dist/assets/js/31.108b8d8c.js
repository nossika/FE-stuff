(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{422:function(t,e,r){"use strict";r.r(e);var s=r(54),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"模块化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),r("h2",{attrs:{id:"模块化方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化方案"}},[t._v("#")]),t._v(" 模块化方案")]),t._v(" "),r("p",[t._v("ESM: 编译时导入（静态），值引用，只读，所以模块导出值的改变会被引用方感知，循环加载时，只要保证使用值时已经有值的定义即可；可用import()实现动态导入。目前普遍做法是利用打包工具（webpack、rollup等）把使用了ESM源码编译成浏览器可识别的JS语法。若在支持ESM的浏览器中，直接使用script标签"),r("code",[t._v('<sript type="module" src="entry.js"/>')]),t._v("即可。")]),t._v(" "),r("p",[t._v("CJS: 运行时导入（动态），值拷贝，所以模块导出值的改变不会体现到引用方，循环引用时，需保证赋值时就有值的定义。NodeJS中默认使用的模块化方案。")]),t._v(" "),r("p",[t._v("AMD：依赖前置，提前加载，如requireJS")]),t._v(" "),r("p",[t._v("CMD：依赖就近，需要时加载，如seaJS")]),t._v(" "),r("p",[t._v("UMD：降级兼容方案(CJS => AMD => 挂载到全局)，一般由打包工具导出")])])}),[],!1,null,null,null);e.default=a.exports}}]);