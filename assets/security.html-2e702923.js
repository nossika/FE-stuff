import{_ as n,M as l,p as s,q as r,R as e,t as a,N as t,V as o,a1 as c}from"./framework-5866ffd3.js";const d={},p=c(`<h1 id="安全" tabindex="-1"><a class="header-anchor" href="#安全" aria-hidden="true">#</a> 安全</h1><h2 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h2><p>浏览器为保护用户信息安全的策略，必须协议、域名、端口都相同才是同源，否则为非同源，也称跨域。</p><h3 id="跨域限制" tabindex="-1"><a class="header-anchor" href="#跨域限制" aria-hidden="true">#</a> 跨域限制</h3><p>浏览器对网络请求、存储资源、DOM资源在跨域情况下会有一些访问限制：</p><ul><li>ajax请求无法跨域读取返回结果</li><li>cookie、localstorage无法跨域读取</li><li>iframe的dom内容无法跨域获取</li><li>跨域script标签的错误内容无法被window.onerror捕获</li></ul><h3 id="绕过跨域" tabindex="-1"><a class="header-anchor" href="#绕过跨域" aria-hidden="true">#</a> 绕过跨域</h3><h4 id="ajax请求无法读取返回结果" tabindex="-1"><a class="header-anchor" href="#ajax请求无法读取返回结果" aria-hidden="true">#</a> ajax请求无法读取返回结果</h4><ul><li><p>CORS，在服务端设置返回http的header设置<code>Access-Control-Allow-Origin</code>为<code>*</code>或者本站域名</p></li><li><p>JSONP，利用script标签无跨域限制的特性，新建script标签，src后面加上回调函数名，服务端把返回结果包装成<code>callback(data)</code>的形式返回</p></li><li><p>改用WebSocket通信，无跨域限制</p></li><li><p>同源服务端转发</p></li></ul><h4 id="cookie、localstorage无法读取" tabindex="-1"><a class="header-anchor" href="#cookie、localstorage无法读取" aria-hidden="true">#</a> cookie、localStorage无法读取</h4><ul><li>如果一级域名相同，只是二级或以后的域名不同，可以设置document.domain为相同域名，即可共享cookie和localStorage</li></ul><h4 id="iframe的dom内容无法获取" tabindex="-1"><a class="header-anchor" href="#iframe的dom内容无法获取" aria-hidden="true">#</a> iframe的DOM内容无法获取</h4><ul><li><p>如果一级域名相同，只是二级或以后的域名不同，可以设置document.domain为相同域名，即可通过<code>document.getElementById(&quot;iframe&quot;).contentWindow.document</code>获取</p></li><li><p>postMessage和监听message事件完成通信</p></li></ul><h4 id="外域script标签的错误内容无法被window-onerror捕获" tabindex="-1"><a class="header-anchor" href="#外域script标签的错误内容无法被window-onerror捕获" aria-hidden="true">#</a> 外域script标签的错误内容无法被window.onerror捕获</h4><ul><li>服务端需要设置<code>Access-Control-Allow-Origin</code>，且script标签需要加上<code>crossorigin</code>属性</li></ul><h2 id="xss" tabindex="-1"><a class="header-anchor" href="#xss" aria-hidden="true">#</a> XSS</h2><p>跨站脚本攻击 (Cross Site Script) ，因信任用户输入，且输出到页面时未转义，使得恶意用户输入的脚本可以被渲染到正常用户的页面上执行。</p><p>场景：</p><ol><li><p>后台对表单输入数据未转义直接存入数据库，并且前端在输出到页面时也未转义，使得恶意用户可以植入代码到其他用户的页面。</p></li><li><p>前端对URL上的参数取值时未转义直接输出到页面，使得恶意用户可以植入代码到URL传播，其他用户误点击后就会在本地页面执行。</p></li></ol><p>应对：</p><ol><li><p>存入数据库前对参数转义、输出到页面时对参数转义，从根源防止</p></li><li><p>CSP防止加载外域资源、发送请求给外域，防止发送本地用户数据给外部服务器</p></li><li><p>Cookie使用HttpOnly，防止Cookie被代码读取</p></li><li><p>使用postMessage通信时，接收方判断origin，且不对传来的参数直接输出或执行</p></li></ol><h3 id="csp" tabindex="-1"><a class="header-anchor" href="#csp" aria-hidden="true">#</a> CSP</h3><p>内容安全策略（Content-Security-Policy），可以限制网站只向可信来源发起请求。</p><p>启用CSP：</p><ul><li>在HTTP的response中加上Content-Security-Policy的header</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Content-Security-Policy: content
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>或者在HTML头部设置http-equiv=&quot;Content-Security-Policy&quot;的meta标签</li></ul><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Content-Security-Policy<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h2><p>跨站请求伪造(Cross Site Request Forgery)，因服务端信任请求来自正常用户，把此请求正常执行或返回数据，被恶意用户利用。</p><p>场景：</p><ol><li>某网站后台仅用cookie来确认用户身份，用户登录恶意网站时，网站可以向该网站暗地发出请求（请求自动带上该网站下的cookie），后台把此请求当做正常用户的请求受理，导致用户信息泄露或者资源损失。</li></ol><p>应对：</p><ol><li><p>使用token：生成token存到cookie或者页面内存，前端请求时读取此token带在header或者body中供后台校验</p></li><li><p>设置Cookie的SameSite，不允许跨域发送Cookie</p></li><li><p>增加验证码，确保操作是真人执行而不是自动发起</p></li></ol><h2 id="点击劫持" tabindex="-1"><a class="header-anchor" href="#点击劫持" aria-hidden="true">#</a> 点击劫持</h2><p>点击劫持（Click Jacking），用户点击某个按钮，却触发了不是用户真正意愿的事件。</p><p>场景：</p><ol><li>恶意网站用iframe内嵌正常网站悬浮在网页上并将iframe透明，诱使用户在页面特定位置进行点击，导致用户在不知情的情况下触发了事件。</li></ol><p>应对：</p><ol><li>使用X-Frame-Options，防止被恶意网站内嵌</li></ol><h2 id="sql注入" tabindex="-1"><a class="header-anchor" href="#sql注入" aria-hidden="true">#</a> SQL注入</h2><h2 id="ddos" tabindex="-1"><a class="header-anchor" href="#ddos" aria-hidden="true">#</a> DDoS</h2><p>攻击结果：用非正常请求占满服务器资源，使得正常用户的请求无法被响应。</p><ul><li><p>flood攻击：持续发送大量请求，占满cpu资源/连接池。</p></li><li><p>慢速攻击：大量慢速请求，占满连接池。</p></li></ul><p>防御：检测异常请求，及时封禁异常请求来源IP。</p><h2 id="waf" tabindex="-1"><a class="header-anchor" href="#waf" aria-hidden="true">#</a> WAF</h2><h2 id="网络劫持" tabindex="-1"><a class="header-anchor" href="#网络劫持" aria-hidden="true">#</a> 网络劫持</h2><p>页面内容监听、篡改</p><p>解决方案：HTTPS</p>`,49),h=e("h2",{id:"内容加密",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#内容加密","aria-hidden":"true"},"#"),a(" 内容加密")],-1),u=e("p",null,"密钥：对称加密、非对称加密",-1),m=e("p",null,"算法：RSA、ECC",-1);function f(k,x){const i=l("RouterLink");return s(),r("div",null,[p,e("blockquote",null,[e("p",null,[a("详见"),t(i,{to:"/web/protocol.html#https"},{default:o(()=>[a("【HTTPS】")]),_:1})])]),h,u,m,e("p",null,[a("RSA算法详见"),t(i,{to:"/algorithm/concept.html#rsa%E5%8A%A0%E5%AF%86"},{default:o(()=>[a("【RSA加密】")]),_:1})])])}const b=n(d,[["render",f],["__file","security.html.vue"]]);export{b as default};
