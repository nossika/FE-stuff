import{_ as i,M as o,p as l,q as u,R as n,t as s,N as a,V as c,a1 as t}from"./framework-5866ffd3.js";const r="/FE-stuff/assets/prototype-6e6116ed.png",d="/FE-stuff/assets/scope-0e2146a6.png",k="/FE-stuff/assets/tail-call-5ec01566.png",m={},v=n("h1",{id:"js-ecma",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#js-ecma","aria-hidden":"true"},"#"),s(" JS(ECMA)")],-1),b=n("h2",{id:"js-和-ecma-的关系",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#js-和-ecma-的关系","aria-hidden":"true"},"#"),s(" JS 和 ECMA 的关系")],-1),h={href:"https://tc39.es/ecma262/",target:"_blank",rel:"noopener noreferrer"},f=t(`<p>JavaScript（JS） 是 ECMAScript 的一种实现，广义的 JS 除了遵循 ECMAScript 标准之外，还基于平台特性提供一些额外 API，比如在浏览器内的 JS 有 DOM 操作相关的 API。</p><p>此章仅讨论 ECMAScript 标准下的 JS，不包括平台相关的特性。</p><h2 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> 类型转换</h2><h3 id="数字转字符串" tabindex="-1"><a class="header-anchor" href="#数字转字符串" aria-hidden="true">#</a> 数字转字符串</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;1&#39;</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;1&#39;</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;1&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="字符串转数字" tabindex="-1"><a class="header-anchor" href="#字符串转数字" aria-hidden="true">#</a> 字符串转数字</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">+</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
Number<span class="token punctuation">.</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对基本类型的属性读写" tabindex="-1"><a class="header-anchor" href="#对基本类型的属性读写" aria-hidden="true">#</a> 对基本类型的属性读写</h3><p>我们可以直接对某个基本类型调用方法，比如<code>&#39;string&#39;.indexOf(&#39;s&#39;)</code>。</p><p>JS 引擎在编译阶段，如果发现有对基本类型的属性读取，则会先将其包装为对应的对象再执行，比如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token string">&#39;asd&#39;</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&#39;s&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token comment">// equal to</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;asd&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&#39;s&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token class-name">Number</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>asd <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asd<span class="token punctuation">;</span> <span class="token comment">// 123</span>
<span class="token comment">// equal to</span>
<span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asd<span class="token punctuation">;</span> <span class="token comment">// 123</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但如果是对属性的写入，则无效，但也不报错：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&#39;asd&#39;</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token string">&#39;f&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 写入失败，但不报错</span>
str<span class="token punctuation">.</span>prop<span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类型的隐式转换" tabindex="-1"><a class="header-anchor" href="#类型的隐式转换" aria-hidden="true">#</a> 类型的隐式转换</h3><p>每个类型的数据都有一个内部的<code>[Symbol.toPrimitive]</code>方法，当需要对数据类型隐式转换时会调用它。</p><p>此方法接收一个<code>hint</code>参数，即<code>[Symbol.toPrimitive](hint)</code>，运行时根据上下文自动按规则决定 hint 取值（string/number/default）。</p><p>内置的<code>[Symbol.toPrimitive](hint)</code>调用流程如下：</p><ul><li><p>string 场景: try <code>data.toString()</code> -&gt; try <code>data.valueOf()</code> -&gt; throw error</p></li><li><p>number/default场景: try <code>data.valueOf()</code> -&gt; try <code>data.String()</code> -&gt; throw error</p></li></ul><p>也可以对<code>[Symbol.toPrimitive]</code>进行改写，搬运一个MDN上的例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// An object without Symbol.toPrimitive property.</span>
<span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// NaN</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>obj1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Object]&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">+</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Object]&quot;</span>

<span class="token comment">// An object with Symbol.toPrimitive property.</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">hint</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hint <span class="token operator">==</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hint <span class="token operator">==</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 10        -- hint is &quot;number&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>obj2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;hello&quot;   -- hint is &quot;string&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2 <span class="token operator">+</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;true&quot;    -- hint is &quot;default&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数字精度问题" tabindex="-1"><a class="header-anchor" href="#数字精度问题" aria-hidden="true">#</a> 数字精度问题</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">0.1</span><span class="token punctuation">;</span> <span class="token comment">// 0.1</span>
<span class="token number">0.2</span><span class="token punctuation">;</span> <span class="token comment">// 0.2</span>
<span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">;</span> <span class="token comment">// 0.30000000000000004</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>0.1 + 0.2 的结果为何不是 0.3?</p><h3 id="ieee-754" tabindex="-1"><a class="header-anchor" href="#ieee-754" aria-hidden="true">#</a> IEEE-754</h3>`,25),g={href:"https://zh.wikipedia.org/wiki/IEEE_754",target:"_blank",rel:"noopener noreferrer"},y=n("strong",null,"IEEE-754",-1),w=t(`<p>此问题是由底层存储结构带来，所有使用 IEEE-754 处理浮点数的语言都有此问题。</p><h3 id="底层存储" tabindex="-1"><a class="header-anchor" href="#底层存储" aria-hidden="true">#</a> 底层存储</h3><p>64 位浮点数的组成：1 符号位 + 11 指数位 + 52 有效数字位。</p><p>如何用 0 和 1 表示小数？对于小数 x，其以二进制表示的方式为：把 x 分解成<code>x = 1/2 * n1 + 1/4 * n2 + 1/8 * n3 + 1/16 * n4 + ...</code>，用其中的 n1n2n3n4... 等因子来作为二进制数字。</p><p>以小数 0.1 为例，<code>0.1 = 1/2 * 0 + 1/4 * 0 + 1/8 * 0 + 1/16 * 1 + 1/32 * 1 + 1/64 * 0 + ...</code> ，则 0.1 的二进制表示为 00011001100...，去掉头部 0，从 1 开始算（头部的 0 有多少可以在指数位表示），则有效数字为 11001100...</p><p>因此大部分小数无法精确存储，除了 0.5/0.125/0.375 这类数字（有效数字刚好有限）。</p><p>回到开头的例子，因为 0.1 和 0.2 本身就不是精确的 0.1 和 0.2，所以他们相加的结果也不是精确的 0.3。</p><h3 id="为何-0-1-本身不精确-还能正常显示-0-1" tabindex="-1"><a class="header-anchor" href="#为何-0-1-本身不精确-还能正常显示-0-1" aria-hidden="true">#</a> 为何 0.1 本身不精确，还能正常显示 0.1？</h3><p>因为 JS 做了自动凑整处理：toPrecision(16)。如果执行<code>(0.1).toPrecision(20)</code>，实际得到的不是<code>0.1</code>，而是<code>0.10000000000000000555</code>。</p><h3 id="toprecision-16-的-16-是哪来的" tabindex="-1"><a class="header-anchor" href="#toprecision-16-的-16-是哪来的" aria-hidden="true">#</a> toPrecision(16) 的 16 是哪来的？</h3><p>因为有效数字部分能显示的最大数字<code>2^53</code>是<code>9007199254740992</code>，即十进制下的 16 位有效数字，超过这个精度的部分会被舍去。所以<code>0.1</code>实际存储的二进制再翻译回来就是<code>0.1000000000000000</code>，把尾部的连续 0 凑整后就是<code>0.1</code>。</p><p>那么如何判断 0.1 + 0.2 === 0.3 呢？ES6 提供了 Number.EPSILON（1 和大于 1 的最小浮点数的差值，即 JS 里数字的最小精度），可以写成 0.1 + 0.2 - 0.3 &lt; Number.EPSILON。</p><h2 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> Array</h2><h3 id="原型方法" tabindex="-1"><a class="header-anchor" href="#原型方法" aria-hidden="true">#</a> 原型方法</h3><p>修改原数组：push / pop / shift / unshift / splice / sort / reverse</p><p>返回新数组：slice / map / filter / concat</p><p>数组遍历相关：forEach / map / filter / some / every / reduce / indexOf / find / includes</p><h2 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h2><h3 id="禁止修改属性" tabindex="-1"><a class="header-anchor" href="#禁止修改属性" aria-hidden="true">#</a> 禁止修改属性</h3><p>Object.freeze(obj)</p><blockquote><p>Object.seal(obj)：同样禁止增删属性，但允许修改现有属性</p></blockquote><p>Reflect.defineProperty(obj, &#39;prop&#39;, { writable: false })</p><p>Reflect.defineProperty(obj, &#39;prop&#39;, { set() {} })</p><h3 id="对象属性遍历" tabindex="-1"><a class="header-anchor" href="#对象属性遍历" aria-hidden="true">#</a> 对象属性遍历</h3><ul><li><p>Object.keys(obj) --- 返回obj实例上的<strong>可枚举属性</strong>名数组</p></li><li><p>Object.getOwnPropertyNames(obj) --- 返回obj实例上的<strong>所有属性名</strong>数组（除了Symbol属性，它们需要通过Object.getOwnPropertySymbols(obj)获取）</p></li><li><p>for (let prop in obj) { ... } --- 遍历obj实例以及<strong>其原型链</strong>上所有可枚举属性</p></li></ul><h2 id="原型-继承" tabindex="-1"><a class="header-anchor" href="#原型-继承" aria-hidden="true">#</a> 原型/继承</h2><h3 id="原型的意义" tabindex="-1"><a class="header-anchor" href="#原型的意义" aria-hidden="true">#</a> 原型的意义</h3><p>假设有些对象都需要有同一个方法fn，要生成n个此类对象。如果每一次都创建一个新的fn给对象，则这个fn需要n份的内存，以后也不方便统一修改；如果创建一个共用的原型，在原型上定义fn，然后把对象和此原型关联起来（此过程也叫继承），则这个fn只需要1份内存，就能让这类对象都拥有这个fn，对原型所做的修改也能让这类对象共享，便于节省空间、统一管理。</p><h3 id="原型继承和类继承" tabindex="-1"><a class="header-anchor" href="#原型继承和类继承" aria-hidden="true">#</a> 原型继承和类继承</h3><p>传统的类继承，需要通过类来创建对象（如JAVA）。</p><p>JS里可以直接创建对象，再设置对象的原型实现继承我，原型只是对象在运行时的一个字段，可以随时被修改，原型继承更加灵活。</p><h3 id="原型、实例、构造函数" tabindex="-1"><a class="header-anchor" href="#原型、实例、构造函数" aria-hidden="true">#</a> 原型、实例、构造函数</h3><p>每个构造函数（constructor）都有一个对应的原型对象（prototype），这个原型对象也包含着指向构造函数的指针，由构造函数生成的每个实例（instance）都包含一个指向原型对象的指针。</p><p>原型、实例、构造函数例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 构造函数 constructor</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例 instance</span>

<span class="token keyword">const</span> protoA <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 原型 prototype</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三者相互访问:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> protoA
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> protoA

proto<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">A</span>
a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">A</span> <span class="token comment">// 实际上等同于 a.__proto__.constructor</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+r+`" alt="prototype"></p><h3 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h3><p>对象内有一个指向原型的指针，指向的这个原型同样也有一个指针（[[Prototype]]）指向它自己的原型，原型继续指向下一个原型，直到顶层，这一串原型称为对象的原型链，原型链的最顶层指向null。对象（obj）的原型可以通过标准方法<code>Object.getPrototypeOf(obj)</code>得到，或者浏览器厂商约定俗成的<code>obj.__proto__</code>。</p><p>访问一个对象（obj）上的属性（prop）时，首先会在这个对象本身搜寻此prop；若找不到，则会沿着obj的原型链往上查找此prop，若找到则返回，找不到则继续沿着原型链往上查找；若直到原型链顶部（null）都找不到，才会返回undefined。</p><h3 id="继承方式" tabindex="-1"><a class="header-anchor" href="#继承方式" aria-hidden="true">#</a> 继承方式</h3><h4 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承" aria-hidden="true">#</a> 组合继承</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> 
<span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">hi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi&#39;</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// B继承A</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成实例b</span>

<span class="token comment">// 测试</span>
b<span class="token punctuation">.</span><span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// print &#39;hi&#39; （继承到了A的方法）</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// A （也继承到了A中this定义的属性，但name属性是定义在a中，b通过原型链找到a，从而访问a.name）</span>
b<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span> <span class="token comment">// A （但构造函数指向A ）</span>

<span class="token comment">// 原型链如下</span>
b<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// a（constructor和__proto__都指向A）</span>
b<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// A.prototype</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改变一下执行顺序</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> 
<span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">hi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi&#39;</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在继承前生成生成实例b</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// B继承A</span>

<span class="token comment">// 测试</span>
b<span class="token punctuation">.</span><span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throw error （没有继承到A的方法）</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// undefined</span>
b<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span> <span class="token comment">// B （构造函数正确）</span>

<span class="token comment">// 原型链如下</span>
b<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 原B.prototype (即prototype指向被改写之前的那个对象)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="寄生组合继承" tabindex="-1"><a class="header-anchor" href="#寄生组合继承" aria-hidden="true">#</a> 寄生组合继承</h4><p>相比于组合继承：省去了一次A的实例化，也去除了B原型上不必要的字段（比如A实例化后的name字段），原型链更加干净。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">hi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi &#39;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> protoClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>protoClass<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  subClass<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inherit</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

b <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
b<span class="token punctuation">.</span><span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//hi b</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="es6-class" tabindex="-1"><a class="header-anchor" href="#es6-class" aria-hidden="true">#</a> ES6 class</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> 
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 测试</span>
b<span class="token punctuation">.</span><span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// print &#39;hi&#39; （继承到了A的方法）</span>
b<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// A （name直接定义在b上，即b.hasOwnProperty(&#39;name&#39;)为true）</span>
b<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span> <span class="token comment">// B （构造函数也正确）</span>

<span class="token comment">// 原型链如下</span>
b<span class="token punctuation">.</span>__proto__ <span class="token comment">// B.prototype（constructor指向B、但__proto__指向A的一个对象）</span>
b<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token comment">// A.prototype</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="create写法" tabindex="-1"><a class="header-anchor" href="#create写法" aria-hidden="true">#</a> create写法</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// proto</span>

<span class="token comment">// 创建一个纯净的对象，实例和原型上都没有任何key，可用来做map存储</span>
<span class="token keyword">const</span> pureObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="一个instanceof问题" tabindex="-1"><a class="header-anchor" href="#一个instanceof问题" aria-hidden="true">#</a> 一个instanceof问题</h3><h4 id="为什么-object-instanceof-function-和-function-instanceof-object-都返回true" tabindex="-1"><a class="header-anchor" href="#为什么-object-instanceof-function-和-function-instanceof-object-都返回true" aria-hidden="true">#</a> 为什么 <code>Object instanceof Function</code> 和 <code>Function instanceof Object</code> 都返回true</h4><p>首先理解一下<code>instanceof</code>这个操作符，它会沿着前者的原型链（<code>__proto__</code>链）寻找是否满足与后者<code>prototype</code>相同的祖先，若找到就返回true，若一直到<code>__proto__</code>链遍历完还是没找到就返回false。</p><p>最简单的例子</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">A</span> <span class="token comment">// 按上述查法，找到a.__proto__等于A.prototype，查找结束，返回true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要知道的几个知识：</p><ol><li>实例的<code>__proto__</code>等于其构造函数的<code>prototype</code>；</li><li>所有函数都是<code>Function</code>的实例，包括<code>Function</code>这个函数自身；</li><li>构造函数的<code>prototype</code>是一个普通对象，自然也是<code>Object</code>的实例。</li></ol><p>现在来看下问题中的<code>Object instanceof Function</code>：</p><p>根据知识2，<code>Object</code>自身虽然是一个构造函数，但也是函数，是<code>Function</code>的实例，再根据知识1得出<code>Object.__proto__</code>等于<code>Function.prototype</code>，返回结果true。</p><p>再看<code>Function instanceof Object</code>：</p><p>由知识2我们知道，<code>Function</code>是构造函数<code>Function</code>的实例，所以根据知识1知道<code>Function.__proto__</code>等于<code>Function.prototype</code>；结合知识1和3，知道<code>Function.prototype.__proto__</code>等于<code>Object.prototype</code>。当沿着<code>Function</code>原型链查找到<code>Function.__proto__.__proto__</code>，也就是<code>Function.prototype.__proto__</code>，它等于<code>Object.prototype</code>，所以也返回true。</p><h2 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h2><p>作用域（scope）即<strong>隔离变量</strong>的一块区域。在JS中分为块级作用域、函数作用域、全局作用域。</p><p>作用域可以用树状结构表示，比如如下例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token comment">// ...</span>

<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">function</span> <span class="token constant">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token constant">C1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token constant">C2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token constant">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token constant">B3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的作用域如图：</p><p><img src="`+d+`" alt="scope"></p><h3 id="作用域链" tabindex="-1"><a class="header-anchor" href="#作用域链" aria-hidden="true">#</a> 作用域链</h3><p>作用域可以沿着它的父作用域、父父作用域一直往上追溯到全局作用域，这条链路称为<strong>作用域链</strong>。在一个作用域中使用了变量时，会优先查找本作用域中的此变量，如果没有则会沿着它的作用域链去查找，一直到全局作用域。作用域只能向祖先访问，无法直接访问其兄弟或者子孙作用域中的变量。</p><p>比如上述例子中，可以在C1作用域中访问到B1、A、global中的变量，但无法直接访问C2、B2中的变量。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>闭包（closure）是<strong>一个函数以及其环境（函数内依赖的变量）的总称</strong>。即使这个函数离开了创建它的环境，依然可以在外部正确执行（正确访问到它依赖的变量），因为函数依赖的变量在函数创建时（编译/解释阶段）已确定，它们会被记录在函数作用域中随着函数一起被保留。</p><p>一般而言，一个函数A执行完毕后，A的内部变量也会被随之销毁。但如果函数A内部定义了一个函数B，且B在A执行完毕后<strong>仍是活跃状态</strong>（可被外部引用，比如『A返回B』、『把B定义为某个按钮的click回调』等情况），那么B内部引用到的变量（即使它们不在B中）也会跟着B一起被保留下来，而不会随着A被销毁。只有当B被释放后，这些变量才会随之释放。</p><p>可以利用这个性质来构造函数的私有变量：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// count只有在fnWithCounter内能访问，外部无法读取或修改</span>
  <span class="token keyword">function</span> <span class="token function">fnWithCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;count: &#39;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> innerCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 这个innerCount与count不同的是，它在fnWithCounter每次执行都会重新创建和销毁，而count可以被持久保留</span>
    <span class="token comment">// do sth.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> fnWithCounter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> fnWithCounter <span class="token operator">=</span> <span class="token function">getFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 此时getFn虽然执行完毕，但其内部创建的count变量和fnWithCounter函数一起被保留下来</span>

<span class="token function">fnWithCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fnWithCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fnWithCounter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 如果执行了这句来释放函数，使原fnWithCounter指向的函数成为非活跃状态（无法从根被访问到），则垃圾回收器可能在下次回收时，释放此函数和其环境占用的内存。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="栈内存、堆内存" tabindex="-1"><a class="header-anchor" href="#栈内存、堆内存" aria-hidden="true">#</a> 栈内存、堆内存</h3><p>栈和堆原意是指某种数据结构，但在谈论存储时也用来指代存储空间。</p><p>栈内存一般认为是线性空间，随着函数的执行而创建，也随着函数退出而自动销毁；堆内存一般认为是大小不定的空间，不会随着函数的退出而销毁，需要手动清理（或者自动GC清理）。</p><p>JS函数执行过程中，对基本类型的定义会将其分配到栈内存，引用类型会分配到堆内存，栈内存中仅保留堆内存的指针。</p><p>发生闭包时上述行为有特殊处理，闭包引用的变量，即使是基本类型，也会分配到堆内存上。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chrome控制台可以通过函数的[[Scopes]]查看Closure。</span>
<span class="token comment">// 可以看到返回的bar函数里，引用到了foo的a就纳入了其闭包环境，未引用到的b则不在其中。</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h2>`,85),j=t(`<h3 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h3><h4 id="promise-all-promise-race" tabindex="-1"><a class="header-anchor" href="#promise-all-promise-race" aria-hidden="true">#</a> Promise.all/Promise.race</h4><h4 id="promise错误处理" tabindex="-1"><a class="header-anchor" href="#promise错误处理" aria-hidden="true">#</a> Promise错误处理</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>无法捕获promise内部错误。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两者区别在于前者无法捕获handler函数内发生的错误，后者可以。</p><h3 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> async/await</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个promise，其resolve时机等于asyncFn内部代码（包括其await）执行完毕时</span>

<span class="token keyword">await</span> promise<span class="token punctuation">;</span> <span class="token comment">// 或者await一个非promise变量，等同于执行await Promise.resolve(val)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h2><p>在ES6之前，JS在语言层面并没有模块相关的规范，CommonJS和AMD是社区上较为主流的模块方案。</p><p>静态导入（ES6标准）：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> a <span class="token keyword">from</span> <span class="token string">&#39;./module-a&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按相关标准，静态导入是会作用于编译阶段，在代码运行之前，所以import不能被包裹在if代码块内</p><p>动态导入（目前还处于提案阶段）：</p><p>作用于运行阶段，所以import后的路径可以是拼接的字符串</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./module-b&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到一个promise</span>

b<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">content</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// module-b的内容content作为promise的结果返回</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17),_=t('<h2 id="尾调用优化" tabindex="-1"><a class="header-anchor" href="#尾调用优化" aria-hidden="true">#</a> 尾调用优化</h2><p>定义：函数的return结果是调用一个函数。</p><p>正常情况下函数内调用函数，在内存会有一个调用栈，来保存下各个函数的调用帧。</p><p>举个例子，有一个函数A，A内部调用了B，B内部又调用了C：</p><p><img src="'+k+`" alt="tail call"></p><p>一般情况下，调用A的执行过程如下：</p><ol><li>对A展开，发现其需要B的返回值，则在调用栈中记录A的调用帧，然后展开计算B</li><li>展开B发现其需要C的返回值，则调用栈也记录下B的调用帧，展开计算C</li><li>C返回结果后，调用栈弹出B的调用帧计算B</li><li>B返回结果后，调用栈弹出A的调用帧计算A</li><li>返回A的结果作为最终返回值，执行完毕</li></ol><p>在尾调用的情况下，A直接返回B的执行结果，B直接返回C的执行结果，调用A的执行过程如下：</p><ol><li>对A展开，发现其直接返回B，则展开计算B，以B的返回值作为A的结果，不记录A</li><li>对B展开，发现其直接返回C，则展开计算C，以C的返回值作为B的结果，不记录B</li><li>展开计算C，以C的返回值作为最终返回值，执行完毕</li></ol><p>此特性一般可以在递归中作为优化手段，把普通递归改为尾调用（尾递归），可以节省大量内存。</p><p>斐波那契数例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 普通递归：fib(5) 展开为 fib(4) + fib(3) 展开为 fib(3) + fib(2) + ... 展开为 fib(2) + fib(1) + ...</span>
<span class="token comment">// 函数会一直展开，调用栈不断往上堆叠</span>

<span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> result <span class="token operator">+</span> total<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 尾递归：fib(5) 替换为 fib(4, 2, 1) 替换为 fib(3, 3, 2) 替换为 fib(2, 5, 3) 替换为 fib(1, 8, 5)</span>
<span class="token comment">// 始终只需要保存最后一层调用帧</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尾调用优化在支持ES6的环境中（严格模式下）默认开启。</p><h2 id="weakmap-weakset" tabindex="-1"><a class="header-anchor" href="#weakmap-weakset" aria-hidden="true">#</a> WeakMap/WeakSet</h2><p>es6 提供了一种特殊的 key-value 数据结构 WeakMap，其特点是不会对 key 造成引用，因而在垃圾回收时允许对 key 回收。</p><p>一个比较典型的例子是用于给 DOM 节点缓存数据：</p><p>Map 写法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#title&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// el 变量引用 #title 这个 DOM 元素</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">&#39;some info&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给 #title 加上自定义信息，map 对 #title 再次引用</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取 #title 的信息</span>
el <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// el 变量清空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后续如果 #title DOM 元素本身被删除，但 map 依然保留对它的引用，所以垃圾回收机制不会清理 #title 节点。</p><p>WeakMap 写法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> weakMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#title&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// el 变量引用 #title 这个 DOM 元素</span>
weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">&#39;some info&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给 #title 加上自定义信息，但 weakMap 对 #title 是弱引用</span>
weakMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取 #title 的信息</span>
el <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// el 变量清空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后续如果 #title DOM 元素本身被删除，而 weakMap 不计入对它的引用，其他地方也没有对它的引用，则垃圾回收机制会清理 #title 节点。</p><p>这也是 WeakMap 不可遍历的一个原因，因为它不保留对 key 的引用，内部的值可以随时被 GC 清除。</p>`,23),x={href:"https://github.com/tc39/proposal-weakrefs",target:"_blank",rel:"noopener noreferrer"},A=t(`<h2 id="with-语法" tabindex="-1"><a class="header-anchor" href="#with-语法" aria-hidden="true">#</a> with 语法</h2><p><code>with(source){prop}</code>被调用时：实际上会先调用<code>prop in source</code>，若返回 true，则<code>prop</code>取<code>source[prop]</code>的值；若false，则跳出 with 作用域继续往上查找，直到找到 prop 或者报错<code>prop is not defined</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

proxy<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token keyword">with</span> <span class="token punctuation">(</span>proxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">;</span> <span class="token comment">// TypeError: a is not defined</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">has </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ?</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

proxy2<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token keyword">with</span> <span class="token punctuation">(</span>proxy2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 a<span class="token punctuation">;</span> <span class="token comment">// 打印出&#39;has a ?&#39;并且返回 1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对象拷贝" tabindex="-1"><a class="header-anchor" href="#对象拷贝" aria-hidden="true">#</a> 对象拷贝</h2><p>JS内的对象是引用类型，当一个对象需要被多个地方使用，但又不希望它们相互影响时，需要对对象作克隆。</p><p>浅拷贝：</p><ul><li>Object.assign(newObj, obj)</li></ul><p>深拷贝：</p><ul><li><p>JSON.parse(JSON.stringify(obj))：丢失object、array和基本类型以外的其他值</p></li><li><p>手动对obj的key递归遍历，赋值到newObj：对引用类型（Set、Map、RegExp等）要手动生成新的</p></li></ul><p>结构化克隆：</p><p>HTML5定义的概念。对象可能通过其他信道传递，对对象序列化，再解析。结构化克隆可以保持除Function、Symbol外的所有类型。</p>`,11),B={href:"https://www.w3.org/TR/html5/infrastructure.html#safe-passing-of-structured-data",target:"_blank",rel:"noopener noreferrer"},S=n("ul",null,[n("li",null,[n("p",null,"window.postMessage")]),n("li",null,[n("p",null,"MessageChannel")]),n("li",null,[n("p",null,"history.pushState")])],-1),C=n("p",null,"函数拷贝：",-1),E=n("p",null,"JS里的函数实例，除了自身逻辑代码，还有包含外部环境的作用域，拷贝函数需要把其整个作用域链也拷贝下来，才能构成一个同样的函数，所以在各种拷贝方式中都没有实现函数拷贝。",-1);function O(M,P){const e=o("ExternalLinkIcon"),p=o("RouterLink");return l(),u("div",null,[v,b,n("p",null,[s("European Computer Manufacturers Association（ECMA）是一个制定计算机标准的机构。"),n("a",h,[s("ECMAScript（ECMA-262）"),a(e)]),s(" 是 ECMA 制定的一种编程语言规范，有跨平台特性。此规范主要由 TC39 团队维护。")]),f,n("p",null,[s("JS 会将能转换成整数的数据都以整数存储。对于小数，使用的是 "),n("a",g,[y,a(e)]),s(" 标准，其底层是用双精度（64 位）浮点数来存储。")]),w,n("blockquote",null,[n("p",null,[s("此处只谈语法使用，原理相关详见"),a(p,{to:"/js/thread.html#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"},{default:c(()=>[s("【事件循环（浏览器）】")]),_:1})])]),j,n("blockquote",null,[n("p",null,[s("其他模块化方案详见"),a(p,{to:"/engineer/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96"},{default:c(()=>[s("【模块化】")]),_:1})])]),_,n("p",null,[s("es2021 更进一步，提供了 "),n("a",x,[s("WeakRef"),a(e)]),s("，可以对用于对任意对象的弱引用。")]),A,n("blockquote",null,[n("p",null,[s("参考文献 "),n("a",B,[s("【Safe passing of structured data】"),a(e)])])]),S,C,E])}const q=i(m,[["render",O],["__file","ecma.html.vue"]]);export{q as default};
