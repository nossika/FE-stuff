import{_ as t,M as p,p as e,q as o,R as n,t as s,N as c,a1 as i}from"./framework-5866ffd3.js";const u={},l=i(`<h1 id="和js对比" tabindex="-1"><a class="header-anchor" href="#和js对比" aria-hidden="true">#</a> 和JS对比</h1><h2 id="设计" tabindex="-1"><a class="header-anchor" href="#设计" aria-hidden="true">#</a> 设计</h2><p>工程化上更加完备： 自带测试框架、性能分析工具、汇编语言预览等</p><p>提供系统底层能力： 用runtime包控制线程调度、用unsafe包读写数据的内存地址和内容等</p><h2 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量" aria-hidden="true">#</a> 局部变量</h2><p>在JS里写if时经常有如下代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">handle</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">handle</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前者污染外部作用域（在if外部作用域定义了一个sum，实际上这个sum可能只会在if中使用），后者有重复代码（a+b写了两次）。</p><p>go可以这么写来定义一个局部变量sum，该变量仅能在if中被访问：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">if</span> sum <span class="token operator">:=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> sum <span class="token operator">&gt;</span> max <span class="token punctuation">{</span>
  <span class="token function">handle</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="函数传参方式" tabindex="-1"><a class="header-anchor" href="#函数传参方式" aria-hidden="true">#</a> 函数传参方式</h2><p>go定义函数时可以指定参数是按引用还是按值（副本）传递</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">ByVal</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
  num <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 修改的只是arr、num副本</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">ByRef</span><span class="token punctuation">(</span>arr <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> num <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token operator">*</span>num <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 可修改外部的arr、num值</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
  num <span class="token operator">:=</span> <span class="token number">1</span>
  <span class="token function">ByVal</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> num<span class="token punctuation">)</span>
  fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token comment">// [1 2 3] 1</span>
  <span class="token function">ByRef</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span>
  fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token comment">// [1 0 3] 0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arr改成切片类型时，情况会有点变化：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">ByVal</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
	<span class="token function">ByVal</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [1 0 3]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和上述例子的区别在于把<code>[3]int</code>改成了<code>[]int</code>，结果arr的值就改变了。</p><p>因为<code>[]int</code>是切片类型，传递到ByVal内部时，同样会创造一个切片副本，但这个arr副本其内部指向的底层数组和函数外部arr是同一个，所以函数内部对arr[1]的改动会直接影响底层数组，其本质还是按值传递的。</p><h2 id="值比较" tabindex="-1"><a class="header-anchor" href="#值比较" aria-hidden="true">#</a> 值比较</h2><p>基本类型间比较 - 直接比较 struct间比较 - 对各个字段比较，如果有不可比较字段则编译报错</p><h2 id="组合替代继承" tabindex="-1"><a class="header-anchor" href="#组合替代继承" aria-hidden="true">#</a> 组合替代继承</h2><p>GO中的继承不同于类继承、原型继承，甚至不像继承，更像是组合。</p><p>struct A需要复用已有struct B的字段时，直接把B写到A的struct声明里，还可以把C、D、E等更多struct一起组合到A里，使得A获得这些struct中的字段。</p><p>如果遇到对一系列对象遍历并调用其方法的场景，一般来说这些对象需要是同一个类，才有共同的类方法，但GO中没有类，用interface来模拟类的行为，这一系列对象不管它们各自的结构是怎样，只要它们都实现了interface中定义的方法，它们就可以当做是一个『类』，就可以放在循环里统一调用interface里的方法。</p><p>组合+接口相比继承的好处：子类不需要知晓父类的实现细节；可运行时动态修改接口背后的实现；更易于复杂的拓展。</p><h2 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理" aria-hidden="true">#</a> 错误处理</h2><p>JS中的错误（throw）和异常都可以用try-catch来处理，并且有冒泡机制。</p><p>GO在设计上把错误（error）和异常（panic）分开对待。</p><p>panic也会冒泡，可以被上层的defer中的recover()捕获到，若没有被捕获，整个程序会退出。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">crash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// panic: arr[5] is out of range</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// runtime error: index out of range [4] with length 4</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">crash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">)</span> <span class="token comment">// never print</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>error则被作为函数返回值返回，强制开发者在第一现场处理（或者忽略），error是一个interface类型。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="协程" tabindex="-1"><a class="header-anchor" href="#协程" aria-hidden="true">#</a> 协程</h2>`,34),r={href:"/js/thread.html#%E5%8D%8F%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"},d=n("p",null,"go在语言层面自己实现了协程goroutine，实现了并行和低资源占用。",-1),k=n("p",null,"goroutine间通过通道通信。",-1),m=n("h2",{id:"垃圾回收",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#垃圾回收","aria-hidden":"true"},"#"),s(" 垃圾回收")],-1),v=n("p",null,"标记-清除法（三色标记） + 写屏障",-1),b=n("p",null,"三色标记：",-1),h=n("p",null,"全部对象默认为白，从root开始，把引用的对象标记为灰，把灰对象的引用的非黑对象继续标记为灰，并把原来的灰对象标记为黑表示已遍历，重复这个过程，直到没有灰对象，剩下的所有白对象则表示没被引用到，销毁全部白对象。",-1),f=n("p",null,"写屏障：GC过程并不STW，程序仍在执行，仍可以修改对象间的引用。GC过程中监听对象修改，将受改动影响的对象直接标记为灰，继续GC。",-1);function g(_,x){const a=p("ExternalLinkIcon");return e(),o("div",null,[l,n("p",null,[s("协程详见"),n("a",r,[s("协程"),c(a)])]),d,k,m,v,b,h,f])}const w=t(u,[["render",g],["__file","diff-js.html.vue"]]);export{w as default};
