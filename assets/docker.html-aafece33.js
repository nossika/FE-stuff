import{_ as e,p as a,q as i,a1 as d}from"./framework-5866ffd3.js";const n={},r=d(`<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><h3 id="仓库-registry" tabindex="-1"><a class="header-anchor" href="#仓库-registry" aria-hidden="true">#</a> 仓库 registry</h3><p>服务器上集中存储镜像的地方，一个仓库通常会包含有多个镜像，以不同tag名来区分。以node仓库为例，它有node:10.15.3-alpine、node:11.13.0-alpine等镜像。</p><h3 id="镜像-image" tabindex="-1"><a class="header-anchor" href="#镜像-image" aria-hidden="true">#</a> 镜像 image</h3><p>定义了将要运行的程序、配置、资源等的打包文件，是一个静态的定义，可以根据一个镜像来运行多个容器。镜像可以从远程仓库拉取，也可从本地自己构建。</p><p>从仓库拉取镜像（registry_url未指定时从默认镜像源拉取；tag_name未指定时，默认为latest标签）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pull [registry_url]registry_name[:tag_name]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据本地Dockerfile构建镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker build dockerfile_path -t image_name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>列出已安装的镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker image ls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除某镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker image rm image_id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="容器-container" tabindex="-1"><a class="header-anchor" href="#容器-container" aria-hidden="true">#</a> 容器 container</h3><p>程序运行的地方，通过镜像来创建，容器可以被创建、启动、停止、删除等。镜像和容器的关系可理解为面向对象编程中类和实例的关系。</p><p>运行容器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -p outer_port:inner_port image_name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看所有容器（-a表示包括已停止容器）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container ls -a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>停止容器（容器停止后默认不会被自动删除，因为可能还要查看日志文件）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container stop container_id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除容器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container rm container_id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h2><p>Dockerfile可用来自定义一个镜像。</p><p>在程序目录下创建一个Dockerfile，在Dockerfile中声明此程序的相关配置，然后docker build这个Dockerfile，即可生成一个docker镜像。</p><p>以一个node程序的Dockerfile为例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>FROM node:latest
COPY . /app
WORKDIR /app
RUN npm install
CMD node index.js
EXPOSE 8888
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>FROM node:latest</li></ul><p>指定程序运行的上层环境为node:latest</p><ul><li>COPY . /app</li></ul><p>把当前路径的全部文件复制到docker镜像的/app</p><ul><li>WORKDIR /app</li></ul><p>指定工作区路径为/app</p><ul><li>RUN npm install</li></ul><p>容器启动前准备，执行npm install</p><ul><li>CMD node index.js</li></ul><p>容器启动后，在工作区路径执行node index.js</p><ul><li>EXPOSE 8888</li></ul><p>对外暴露8888端口</p><h2 id="分层存储" tabindex="-1"><a class="header-anchor" href="#分层存储" aria-hidden="true">#</a> 分层存储</h2>`,42),l=[r];function t(s,c){return a(),i("div",null,l)}const u=e(n,[["render",t],["__file","docker.html.vue"]]);export{u as default};
