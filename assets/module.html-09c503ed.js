import{_ as e,p as a,q as t,a1 as i}from"./framework-5866ffd3.js";const r={},o=i('<h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h1><h2 id="模块规范" tabindex="-1"><a class="header-anchor" href="#模块规范" aria-hidden="true">#</a> 模块规范</h2><ul><li><p>ESM: 编译时导入（静态），导入的是值的引用（只读），所以模块导出值的改变会被引用方感知（循环引用情况下，只要保证执行至使用值的地方时，已经有对应的值即可）；可用import()实现动态导入。目前普遍做法是利用打包工具（webpack、rollup等）把使用了ESM源码编译成浏览器可识别的JS语法。若在支持ESM的浏览器中，直接使用script标签<code>&lt;sript type=&quot;module&quot; src=&quot;entry.js&quot;/&gt;</code>即可</p></li><li><p>CJS: 运行时导入（动态），导入的是值的拷贝，所以模块导出值的改变不会影响到引用方（循环引用时，需保证取值时就有对应的值）。可以在条件语句中引入模块，可以引入动态路径的模块。NodeJS中默认使用的模块化方案</p></li><li><p>UMD：降级兼容方案，CJS =&gt; AMD =&gt; 挂载到全局（window/global），一般由打包工具导出</p></li><li><p>AMD：依赖前置，提前加载，如requireJS</p></li><li><p>CMD：依赖就近，需要时加载，如seaJS</p></li></ul><h2 id="差异" tabindex="-1"><a class="header-anchor" href="#差异" aria-hidden="true">#</a> 差异</h2><p>主流模块化方案是 esm 和 cjs。</p><p>从规范上看，二者最根本的差异是建立模块关联的阶段不同：编译时（esm） vs 运行时（cjs），从而导致了一系列表现上的差异：能否嵌套在条件语句、是否支持动态路径、循环引用时的取值等。</p><p>相同之处是，同一程序中（“程序”对于 node 是一个进程，对于 web 是一个 spa），引用的模块都是按“单例”处理，即同一公共模块被不同业务模块引用时，实际激活的模块内存是同一份，即业务模块对其内部数据的改动会影响其他业务模块。</p>',7),l=[o];function s(d,c){return a(),t("div",null,l)}const n=e(r,[["render",s],["__file","module.html.vue"]]);export{n as default};
