import{_ as e,p as t,q as a,a1 as r}from"./framework-5866ffd3.js";const o={},c=r('<h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h1><h2 id="模块化方案" tabindex="-1"><a class="header-anchor" href="#模块化方案" aria-hidden="true">#</a> 模块化方案</h2><p>ESM: 编译时导入（静态），值引用，只读，所以模块导出值的改变会被引用方感知，循环加载时，只要保证使用值时已经有值的定义即可；可用import()实现动态导入。目前普遍做法是利用打包工具（webpack、rollup等）把使用了ESM源码编译成浏览器可识别的JS语法。若在支持ESM的浏览器中，直接使用script标签<code>&lt;sript type=&quot;module&quot; src=&quot;entry.js&quot;/&gt;</code>即可。</p><p>CJS: 运行时导入（动态），值拷贝，所以模块导出值的改变不会体现到引用方，循环引用时，需保证赋值时就有值的定义。NodeJS中默认使用的模块化方案。</p><p>AMD：依赖前置，提前加载，如requireJS</p><p>CMD：依赖就近，需要时加载，如seaJS</p><p>UMD：降级兼容方案(CJS =&gt; AMD =&gt; 挂载到全局)，一般由打包工具导出</p>',7),d=[c];function s(p,i){return t(),a("div",null,d)}const h=e(o,[["render",s],["__file","module.html.vue"]]);export{h as default};
