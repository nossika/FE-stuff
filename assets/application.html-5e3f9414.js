import{_ as a,p,q as e,a1 as t}from"./framework-5866ffd3.js";const r={},d=t('<h1 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h1><h2 id="rsa加密" tabindex="-1"><a class="header-anchor" href="#rsa加密" aria-hidden="true">#</a> RSA加密</h2><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法" aria-hidden="true">#</a> 用法</h3><p>密钥a：e（指数），n（模） 密钥b：d（指数），n（模）</p><p>用密钥a把M加密为C：C = M ** e (mod n) 用密钥b把C还原为M：M = C ** d (mod n)</p><p>也可以反过来用密钥b加密，密钥a还原，从数学上密钥a、b完全可以交换使用。但在实际运用中，一般会生成一个指数较小的（或者固定的）数作为公钥开放（客户端使用起来更方便），指数较大的数作为私钥。如果将它们交换，相当于用一个指数较小的数作为私钥，较容易被反推出来，不安全。</p><h3 id="密钥对生成" tabindex="-1"><a class="header-anchor" href="#密钥对生成" aria-hidden="true">#</a> 密钥对生成</h3><p>生成e，d，n过程：</p><p>1、选取两个足够大的素数：p、q</p><p>2、n = p * q</p><p>3、m = (p - 1) * (q - 1)</p><p>4、找一个与m互质的数e，且1 &lt; e &lt; m</p><p>5、找出d，使得d * e (mod m) = 1</p><p>6、生成完毕，密钥a：(e, n)，密钥b：(d, n)</p><h3 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性" aria-hidden="true">#</a> 安全性</h3><p>安全性是基于：大素数分解困难。在这个条件成立的前提下，通过已知的大素数n难以反推出p、q，所以也难以推出e、d，因此密钥a、b虽然可以相互加密解密，但算出另一密钥是困难的。</p><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h3><p>生成密钥对</p><p>1、选取两个素数 p = 3 ，q = 11（为方便举例选取了较小的素数）</p><p>2、n = p * q = 3 * 11 = 33</p><p>3、m = (p - 1) * (q - 1) = (3 - 1) * (11 - 1) = 20</p><p>4、从比m小的数中找出一个与m互质的数 e = 3</p><p>5、可以通过穷举法，d从1开始递增，试出满足条件的最小的d = 7</p><p>6、得出一对密钥：密钥a：(3, 33)，密钥b：(7, 33)</p><p>对&#39;rsa&#39;这个字符串加密</p><p>1、对‘rsa’进行数字化转化，&#39;r&#39;，‘s&#39;，’a&#39;可以转化成其对应字母表次序：18、19、1</p><p>2、用密钥a加密：</p><p>r =&gt; 18 =&gt; 18 ** 3 % 33 =&gt; 24</p><p>s =&gt; 19 =&gt; 19 ** 3 % 33 =&gt; 28</p><p>a =&gt; 1 =&gt; 1 ** 3 % 33 =&gt; 1</p><p>加密后：[&#39;r&#39;, &#39;s&#39;, &#39;a&#39;] =&gt; [24, 28, 1]</p><p>对加密后的[24, 28, 1]进行还原</p><p>1、用密钥b解密</p><p>24 =&gt; 24 ** 7 % 33 =&gt; 18 =&gt; r</p><p>28 =&gt; 28 ** 7 % 33 =&gt; 19 =&gt; s</p><p>1 =&gt; 1 ** 7 % 33 =&gt; 1 =&gt; a</p><p>得出结果&#39;rsa&#39;</p><h2 id="huffman压缩" tabindex="-1"><a class="header-anchor" href="#huffman压缩" aria-hidden="true">#</a> Huffman压缩</h2><p>原理：根据文件中各字符的出现频率对字符重新编码，越高频的字符给予越短的编码，来降低文件整体数据量。</p><ol><li>读取文件，得到各字符频率表。</li><li>根据频率表，构建Huffman树（从数组每次取最小的两个值；两个值分别作为左右节点，两值之和作为父节点建立一个子树；并将父节点放入数组，重复取值操作，直到数组内的项全部转化成树。最后构建出来的树满足值越小离根节点越远）。</li><li>根据Huffman树，建立字符与编码的映射表，越靠近根节点的字符对应的编码越短。</li><li>根据映射表，对原文件重新编译，得到编译后的文件。</li><li>把编译后的文件和配置信息（包括Huffman树）打包成为最后的输出文件，完成压缩。</li><li>解压时，根据配置信息对编译后的文件进行还原，得到原文件。</li></ol>',40),i=[d];function n(h,s){return p(),e("div",null,i)}const c=a(r,[["render",n],["__file","application.html.vue"]]);export{c as default};
