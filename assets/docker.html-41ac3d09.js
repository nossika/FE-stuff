import{_ as e,p as a,q as n,a1 as s}from"./framework-5866ffd3.js";const i={},d=s(`<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h2><p>构建镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker build -t &lt;image&gt;:&lt;tag&gt; -f &lt;path/to/Dockerfile&gt; .
docker build -t my-app:latest -f ./Dockerfile .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>按镜像启动容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>local_port<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>docker_expose_port<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8000 my-app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>命令行调试容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--platform</span> <span class="token operator">&lt;</span>platform<span class="token operator">&gt;</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span> /bin/sh
<span class="token function">docker</span> run <span class="token parameter variable">--platform</span> linux/amd64 <span class="token parameter variable">-it</span> my-app /bin/sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>推送镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker push &lt;image&gt;:&lt;tag&gt;
docker push my-app:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>涉及远程资源获取或更新的操作，需要先执行docker login。</p><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><h3 id="仓库-registry" tabindex="-1"><a class="header-anchor" href="#仓库-registry" aria-hidden="true">#</a> 仓库 registry</h3><p>服务器上集中存储镜像的地方，一个仓库通常会包含有多个镜像，以不同tag名来区分。以node仓库为例，它有node:10.15.3-alpine、node:11.13.0-alpine等镜像。</p><h3 id="镜像-image" tabindex="-1"><a class="header-anchor" href="#镜像-image" aria-hidden="true">#</a> 镜像 image</h3><p>定义了将要运行的程序、配置、资源等的打包文件，是一个静态的定义，可以根据一个镜像来运行多个容器。镜像可以从远程仓库拉取，也可从本地自己构建。</p><p>从仓库拉取镜像（registry_url未指定时从默认镜像源拉取；tag_name未指定时，默认为latest标签）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pull [registry_url]&lt;registry_name&gt;[:tag_name]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据本地Dockerfile构建镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker build &lt;dockerfile_path&gt; -t &lt;image_name&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>列出已安装的镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker image ls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除某镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker image rm &lt;image_id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="容器-container" tabindex="-1"><a class="header-anchor" href="#容器-container" aria-hidden="true">#</a> 容器 container</h3><p>程序运行的地方，通过镜像来创建，容器可以被创建、启动、停止、删除等。镜像和容器的关系可理解为面向对象编程中类和实例的关系。</p><p>运行容器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -p &lt;outer_port&gt;:&lt;inner_port&gt; &lt;image_name&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看所有容器（-a表示包括已停止容器）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container ls -a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>停止容器（容器停止后默认不会被自动删除，因为可能还要查看日志文件）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container stop &lt;container_id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除容器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker container rm &lt;container_id&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h2><p>Dockerfile可用来自定义一个镜像。</p><p>在程序目录下创建一个Dockerfile，在Dockerfile中声明此程序的相关配置，然后docker build这个Dockerfile，即可生成一个docker镜像。</p><p>以一个node程序的Dockerfile为例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>FROM node:latest
COPY . /app
WORKDIR /app
RUN npm install
CMD node index.js
EXPOSE 8888
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>FROM node:latest</li></ul><p>指定程序运行的上层环境为node:latest</p><ul><li>COPY . /app</li></ul><p>把当前路径的全部文件复制到docker镜像的/app</p><ul><li>WORKDIR /app</li></ul><p>指定工作区路径为/app</p><ul><li>RUN npm install</li></ul><p>容器启动前准备，执行npm install</p><ul><li>CMD node index.js</li></ul><p>容器启动后，在工作区路径执行node index.js</p><ul><li>EXPOSE 8888</li></ul><p>对外暴露8888端口</p><h2 id="镜像分层" tabindex="-1"><a class="header-anchor" href="#镜像分层" aria-hidden="true">#</a> 镜像分层</h2><p>在构建镜像时，Dockerfile 中的一条指令会对应创建一个镜像层，下次构建会尽量复用之前的镜像层，来加速构建和节省空间。</p><p>如果检测到某一层的结果有变动，则 docker 会复用之前的层，但重新构建变动层及其之后的层。</p>`,54),t=[d];function r(l,c){return a(),n("div",null,t)}const o=e(i,[["render",r],["__file","docker.html.vue"]]);export{o as default};
