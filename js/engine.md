

# V8引擎

## 简介

V8是google开源的JS引擎，由C++编写，被应用于Chrome、NodeJS等，其他JS引擎有Rhino、JavaScriptCore、Chakra等。

V8中做的性能优化有：

- JIT编译优化

- 隐藏类

- 高效垃圾回收

- etc.

> 一个可调试V8的库：https://github.com/GoogleChromeLabs/jsvu

## Just-In-Time编译（内联缓存）

JS是弱类型动态语言，在源码生成AST以后，就开始边解释边执行，且因为变量类型不固定，运行时需边判断类型边操作，由此有了优化空间。

JIT加入**监视器**来分析代码片段的运行情况，如果某代码片段被执行次数越多，则对其进行越深层的优化。因为优化也需要代价，所以加入监视器来对优化收益更高的代码进行更多优化操作，以提高整体执行效率。

当某代码片段进入“warm”阶段，JIT对其进行**基线编译**并缓存，下次进入此代码片段时，如果变量类型没变，则直接使用这个编译后的版本来运行，节省再次执行解释的时间。

当某代码片段进入“hot”阶段，JIT会对其作更高效的**优化编译**，为此需要做一些假设（比如每次某变量使用的对象都有相同结构），针对这一假设再作优化程度更高的编译。如果某次执行中发现假设出错（比如对象结构变了），则放弃优化编译退回基线编译。如果代码片段多次从优化编译退回基线编译，则放弃对此片段的优化编译。

代码编译的优化也称**内联缓存**，根据数据结构的类型是单一还是多个，分为单态和多态，单态的效率大于多态，也就是说对于同个函数调用，其数据结构越单一越好。

## 隐藏类（快属性）

因为JS的对象只有原型，没有严格意义上的类，所以无法在编译时就为对象分配好固定的空间。

V8里的对象内部有两类存储结构，elements和properties：elements的key为数字，可以通过key直接得出内存偏移量来找到对应value；properties为字典表（哈希表），需要对key做一次转换才能得出value的内存位置。数据会尽可能地存储到elements结构里，比如常规的紧密数组、以数字为key的数据（且数据量小）等。

对于properties类型的数据而言，如果每次访问value都去翻译一次key来做内存位置查找，对于大量结构相同的数据是一种浪费。所以V8为properties加上了一个隐藏类，隐藏类里包含了其key值和对应的位置信息，把同结构的properties指向同一个隐藏类，这样在对properties读key时，只需从其隐藏类中直接获取这个key的位置即可。

隐藏类会在运行时改变，对象的创建、赋值key、赋值顺序、删除key等操作都可能带来隐藏类的改变。对于同一类对象，应尽量让它们都指向同一隐藏类，来提升性能。

good case:

```js
const arr = [];

for (let i = 0; i < 10000; i++) {
  const obj = {};

  if (condition1) {
    obj.a = 1; // 此时obj隐藏类为shape(a)
    obj.b = 2; // 此时obj隐藏类加上了b，为shape(a, b)
  } else if {
    obj = {
      a: 11,
      b: 22,
    }; // 这种写法会使obj隐藏类直接为shape(a, b)，也和上面一致

    obj.b = undefined; // obj还是保持着隐藏类shape(a, b)的结构
  } 

  arr.push(obj);
}

arr.forEach(obj => {
  console.log(obj.a); // 全部的obj都指向同一隐藏类shape(a, b)，访问obj.a时不必再重复计算a的位置，直接从隐藏类中获取
});
```

bad case:

```js
for (let i = 0; i < 10000; i++) {
  const obj = {};
  if (condition1) {
    obj.a = 1; // shape(a)
    obj.b = 2; // shape(a, b)
  } else if (condition2) {
    obj.b = 1; // shape(b)
    obj.a = 2; // shape(b, a)
  } else if (condition3) {
    obj.a = 1; // shape(a)
    obj.b = 2; // shape(a, b)
    obj.c = 3; // shape(a, b, c)
  } else if (condition4) {
    obj = { a: 1, b: 2 }; // shape(a, b)
    Reflect.deleteProperty(obj, 'b'); // 隐藏类回退到shape(a)
  }

  // 以上各逻辑分支创造出的obj隐藏类都各不相同
}

```

在chrome的memory抓取内存快照，查看对象的结构，其中`system / Map`指向的就是其隐藏类。

## 快数组

通常意义的数组是指元素类型一致、占用空间一致、内存上连续的一组数据。这样初始化时，通过容量大小即可确定分配的内存空间；通过数组下标访问元素时，仅需通过下标值乘以占用空间就能得到内存偏移量，即可获取到对应元素。

而JS的数组是可以存放不同类型的元素的，且不需要提前声明容量。此类场景更适合用哈希表实现。

所以V8内部对于数组有两种实现：FixedArray（快数组） / HashTable（慢数组）。FixedArray即通常意义的数组，有元素空间大小一致、内存连续等特性；HashTable即哈希表封装而成的数组，也提供了pop、push等方法，但内存非连续。V8还对FixedArray做了自动扩缩容，在数组操作过程中动态改变数组容量。

V8会尽可能地将数组以FixedArray的形式实现，来使数组有更好的性能。但需要满足一些条件：元素都为某几类元素、大部分元素排列紧密等。V8运行过程中会适时根据条件，把数组实现在FixedArray和HashTable互相切换。

### 稀疏数组

前面提到”数组紧密排列“，数组有紧密数组（PACKED）和稀疏数组（HOLEY）的区别。比如下面方式即可构造出一个稀疏数组：

```
const arr = [1];
arr[1000] = 1;
console.log(arr); // [1, empty × 999, 1]
arr.forEach(n => console.log(n)); // 1, 1
```

数组中未被初始化的元素即为稀疏元素，用empty表示，并且遍历时会被跳过。

如果一个FixedArray数组中加入大量稀疏元素，则V8会将底层结构切换为HashTable，来减少内存空间占用。

## 垃圾回收

V8采用了分代GC，将内存划分为：

- 新生代区：大部分对象在此区，区域小但垃圾回收频繁
- 老生代区：从新生代晋升而来的生存周期长的对象
- 大对象区：占用空间较大的对象
- 代码区：唯一拥有执行权限的区域

### 新生代区

采用复制算法（scavenge）做垃圾回收（GC）

内存空间分为两半---from区和to区，from区是处于使用状态的内存，新对象都会分配到from区，当GC开始时（如from区存满时），引擎会扫描出活跃对象（从root开始扫描，从root作BFS遍历其能访问的所有对象），复制到to区，这样to区就都为活跃对象，然后交换from区和to区内容，释放to区。

由于此区大部分对象是非活跃，所以复制操作代价小，空间上有一半是处于空置状态（to区），但因为此区空间本身就小，所以可以接受这种空置，牺牲空间带来的好处是只需要作一次复制遍历，而不用进行标记+清除两次遍历。

当此区的对象经过多次GC依然存活，说明其生命周期较长，对象会被移动到老生代区，此过程称为对象晋升。

### 老生代区

采用标记-清除算法（mark-sweep）做GC

不再采用复制算法，因为此区空间较大，空置一半的空间太浪费，且大量活跃对象的复制代价大。此算法采用DFS遍历来标记活跃对象，标记结束后将非活跃对象（未被标记的对象）直接清除。

标记-清除操作会产生内存碎片（内存空间不连续），当空间不足时执行标记-整理算法（mark-compact）来整理内存。



	
